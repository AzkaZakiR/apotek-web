
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions

export type PrismaPromise<T> = $Public.PrismaPromise<T>


export type ObatPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Obat"
  objects: {
    staff: Staff_gudangPayload<ExtArgs>
    supplier: SupplierPayload<ExtArgs>
    det_pembelian: Det_pembelianPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    nama_obat: string | null
    gambar: string | null
    jenis_obat: string | null
    tipe_obat: string | null
    tanggal_expired: string | null
    jumlah: number | null
    harga_beli: number
    harga_jual: number
    stok_obat: number | null
    kategori_obat: string | null
    sub_kategori: string | null
    created_at: Date
    updated_at: Date
    id_staff: string
    id_supplier: string
  }, ExtArgs["result"]["obat"]>
  composites: {}
}

/**
 * Model Obat
 * 
 */
export type Obat = runtime.Types.DefaultSelection<ObatPayload>
export type PembelianPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Pembelian"
  objects: {
    pelanggan: PelangganPayload<ExtArgs>
    apoteker: ApotekerPayload<ExtArgs>
    det_pembelian: Det_pembelianPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    jumlah_jual: number | null
    total_harga: number
    tanggal_beli: Date | null
    jumlah_beli: string | null
    id_pelanggan: string
    id_apoteker: string
  }, ExtArgs["result"]["pembelian"]>
  composites: {}
}

/**
 * Model Pembelian
 * 
 */
export type Pembelian = runtime.Types.DefaultSelection<PembelianPayload>
export type Det_pembelianPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Det_pembelian"
  objects: {
    pembelian: PembelianPayload<ExtArgs>
    obat: ObatPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    id_faktur: string
    id_obat: string
  }, ExtArgs["result"]["det_pembelian"]>
  composites: {}
}

/**
 * Model Det_pembelian
 * 
 */
export type Det_pembelian = runtime.Types.DefaultSelection<Det_pembelianPayload>
export type Staff_gudangPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Staff_gudang"
  objects: {
    Obat: ObatPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }, ExtArgs["result"]["staff_gudang"]>
  composites: {}
}

/**
 * Model Staff_gudang
 * 
 */
export type Staff_gudang = runtime.Types.DefaultSelection<Staff_gudangPayload>
export type SupplierPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Supplier"
  objects: {
    Obat: ObatPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }, ExtArgs["result"]["supplier"]>
  composites: {}
}

/**
 * Model Supplier
 * 
 */
export type Supplier = runtime.Types.DefaultSelection<SupplierPayload>
export type ApotekerPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Apoteker"
  objects: {
    laporan: LaporanPayload<ExtArgs>[]
    pembelian: PembelianPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }, ExtArgs["result"]["apoteker"]>
  composites: {}
}

/**
 * Model Apoteker
 * 
 */
export type Apoteker = runtime.Types.DefaultSelection<ApotekerPayload>
export type PelangganPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Pelanggan"
  objects: {
    pembelian: PembelianPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: string
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }, ExtArgs["result"]["pelanggan"]>
  composites: {}
}

/**
 * Model Pelanggan
 * 
 */
export type Pelanggan = runtime.Types.DefaultSelection<PelangganPayload>
export type LaporanPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Laporan"
  objects: {
    apoteker: ApotekerPayload<ExtArgs>
    pemilik: PemilikPayload<ExtArgs>
  }
  scalars: $Extensions.GetResult<{
    id: string
    isi_laporan: string
    tanggal_laporan: string
    id_apoteker: string
    id_pemilik: number
  }, ExtArgs["result"]["laporan"]>
  composites: {}
}

/**
 * Model Laporan
 * 
 */
export type Laporan = runtime.Types.DefaultSelection<LaporanPayload>
export type PemilikPayload<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
  name: "Pemilik"
  objects: {
    laporan: LaporanPayload<ExtArgs>[]
  }
  scalars: $Extensions.GetResult<{
    id: number
    Nama: string | null
    Alamat: string | null
    no_telp: string | null
  }, ExtArgs["result"]["pemilik"]>
  composites: {}
}

/**
 * Model Pemilik
 * 
 */
export type Pemilik = runtime.Types.DefaultSelection<PemilikPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Obats
 * const obats = await prisma.obat.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Obats
   * const obats = await prisma.obat.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.obat`: Exposes CRUD operations for the **Obat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Obats
    * const obats = await prisma.obat.findMany()
    * ```
    */
  get obat(): Prisma.ObatDelegate<ExtArgs>;

  /**
   * `prisma.pembelian`: Exposes CRUD operations for the **Pembelian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pembelians
    * const pembelians = await prisma.pembelian.findMany()
    * ```
    */
  get pembelian(): Prisma.PembelianDelegate<ExtArgs>;

  /**
   * `prisma.det_pembelian`: Exposes CRUD operations for the **Det_pembelian** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Det_pembelians
    * const det_pembelians = await prisma.det_pembelian.findMany()
    * ```
    */
  get det_pembelian(): Prisma.Det_pembelianDelegate<ExtArgs>;

  /**
   * `prisma.staff_gudang`: Exposes CRUD operations for the **Staff_gudang** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Staff_gudangs
    * const staff_gudangs = await prisma.staff_gudang.findMany()
    * ```
    */
  get staff_gudang(): Prisma.Staff_gudangDelegate<ExtArgs>;

  /**
   * `prisma.supplier`: Exposes CRUD operations for the **Supplier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Suppliers
    * const suppliers = await prisma.supplier.findMany()
    * ```
    */
  get supplier(): Prisma.SupplierDelegate<ExtArgs>;

  /**
   * `prisma.apoteker`: Exposes CRUD operations for the **Apoteker** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apotekers
    * const apotekers = await prisma.apoteker.findMany()
    * ```
    */
  get apoteker(): Prisma.ApotekerDelegate<ExtArgs>;

  /**
   * `prisma.pelanggan`: Exposes CRUD operations for the **Pelanggan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pelanggans
    * const pelanggans = await prisma.pelanggan.findMany()
    * ```
    */
  get pelanggan(): Prisma.PelangganDelegate<ExtArgs>;

  /**
   * `prisma.laporan`: Exposes CRUD operations for the **Laporan** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Laporans
    * const laporans = await prisma.laporan.findMany()
    * ```
    */
  get laporan(): Prisma.LaporanDelegate<ExtArgs>;

  /**
   * `prisma.pemilik`: Exposes CRUD operations for the **Pemilik** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Pemiliks
    * const pemiliks = await prisma.pemilik.findMany()
    * ```
    */
  get pemilik(): Prisma.PemilikDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export type Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export type Args<T, F extends $Public.Operation> = $Public.Args<T, F>
  export type Payload<T, F extends $Public.Operation> = $Public.Payload<T, F>
  export type Result<T, A, F extends $Public.Operation> = $Public.Result<T, A, F>
  export type Exact<T, W> = $Public.Exact<T, W>

  /**
   * Prisma Client JS version: 5.0.0
   * Query Engine version: 6b0aef69b7cdfc787f822ecd7cdc76d5f1991584
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Obat: 'Obat',
    Pembelian: 'Pembelian',
    Det_pembelian: 'Det_pembelian',
    Staff_gudang: 'Staff_gudang',
    Supplier: 'Supplier',
    Apoteker: 'Apoteker',
    Pelanggan: 'Pelanggan',
    Laporan: 'Laporan',
    Pemilik: 'Pemilik'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.Args}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'obat' | 'pembelian' | 'det_pembelian' | 'staff_gudang' | 'supplier' | 'apoteker' | 'pelanggan' | 'laporan' | 'pemilik'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Obat: {
        payload: ObatPayload<ExtArgs>
        fields: Prisma.ObatFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ObatFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ObatPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ObatFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ObatPayload>
          }
          findFirst: {
            args: Prisma.ObatFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ObatPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ObatFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ObatPayload>
          }
          findMany: {
            args: Prisma.ObatFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ObatPayload>[]
          }
          create: {
            args: Prisma.ObatCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ObatPayload>
          }
          createMany: {
            args: Prisma.ObatCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ObatDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ObatPayload>
          }
          update: {
            args: Prisma.ObatUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ObatPayload>
          }
          deleteMany: {
            args: Prisma.ObatDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ObatUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ObatUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ObatPayload>
          }
          aggregate: {
            args: Prisma.ObatAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateObat>
          }
          groupBy: {
            args: Prisma.ObatGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ObatGroupByOutputType>[]
          }
          count: {
            args: Prisma.ObatCountArgs<ExtArgs>,
            result: $Utils.Optional<ObatCountAggregateOutputType> | number
          }
        }
      }
      Pembelian: {
        payload: PembelianPayload<ExtArgs>
        fields: Prisma.PembelianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PembelianFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PembelianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PembelianFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PembelianPayload>
          }
          findFirst: {
            args: Prisma.PembelianFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PembelianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PembelianFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PembelianPayload>
          }
          findMany: {
            args: Prisma.PembelianFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PembelianPayload>[]
          }
          create: {
            args: Prisma.PembelianCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PembelianPayload>
          }
          createMany: {
            args: Prisma.PembelianCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PembelianDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PembelianPayload>
          }
          update: {
            args: Prisma.PembelianUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PembelianPayload>
          }
          deleteMany: {
            args: Prisma.PembelianDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PembelianUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PembelianUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PembelianPayload>
          }
          aggregate: {
            args: Prisma.PembelianAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePembelian>
          }
          groupBy: {
            args: Prisma.PembelianGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PembelianGroupByOutputType>[]
          }
          count: {
            args: Prisma.PembelianCountArgs<ExtArgs>,
            result: $Utils.Optional<PembelianCountAggregateOutputType> | number
          }
        }
      }
      Det_pembelian: {
        payload: Det_pembelianPayload<ExtArgs>
        fields: Prisma.Det_pembelianFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Det_pembelianFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Det_pembelianPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Det_pembelianFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Det_pembelianPayload>
          }
          findFirst: {
            args: Prisma.Det_pembelianFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Det_pembelianPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Det_pembelianFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Det_pembelianPayload>
          }
          findMany: {
            args: Prisma.Det_pembelianFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Det_pembelianPayload>[]
          }
          create: {
            args: Prisma.Det_pembelianCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Det_pembelianPayload>
          }
          createMany: {
            args: Prisma.Det_pembelianCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Det_pembelianDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Det_pembelianPayload>
          }
          update: {
            args: Prisma.Det_pembelianUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Det_pembelianPayload>
          }
          deleteMany: {
            args: Prisma.Det_pembelianDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Det_pembelianUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Det_pembelianUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Det_pembelianPayload>
          }
          aggregate: {
            args: Prisma.Det_pembelianAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateDet_pembelian>
          }
          groupBy: {
            args: Prisma.Det_pembelianGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Det_pembelianGroupByOutputType>[]
          }
          count: {
            args: Prisma.Det_pembelianCountArgs<ExtArgs>,
            result: $Utils.Optional<Det_pembelianCountAggregateOutputType> | number
          }
        }
      }
      Staff_gudang: {
        payload: Staff_gudangPayload<ExtArgs>
        fields: Prisma.Staff_gudangFieldRefs
        operations: {
          findUnique: {
            args: Prisma.Staff_gudangFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Staff_gudangPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.Staff_gudangFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Staff_gudangPayload>
          }
          findFirst: {
            args: Prisma.Staff_gudangFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Staff_gudangPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.Staff_gudangFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Staff_gudangPayload>
          }
          findMany: {
            args: Prisma.Staff_gudangFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Staff_gudangPayload>[]
          }
          create: {
            args: Prisma.Staff_gudangCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Staff_gudangPayload>
          }
          createMany: {
            args: Prisma.Staff_gudangCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.Staff_gudangDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Staff_gudangPayload>
          }
          update: {
            args: Prisma.Staff_gudangUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Staff_gudangPayload>
          }
          deleteMany: {
            args: Prisma.Staff_gudangDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.Staff_gudangUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.Staff_gudangUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Staff_gudangPayload>
          }
          aggregate: {
            args: Prisma.Staff_gudangAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStaff_gudang>
          }
          groupBy: {
            args: Prisma.Staff_gudangGroupByArgs<ExtArgs>,
            result: $Utils.Optional<Staff_gudangGroupByOutputType>[]
          }
          count: {
            args: Prisma.Staff_gudangCountArgs<ExtArgs>,
            result: $Utils.Optional<Staff_gudangCountAggregateOutputType> | number
          }
        }
      }
      Supplier: {
        payload: SupplierPayload<ExtArgs>
        fields: Prisma.SupplierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupplierFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupplierFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplierPayload>
          }
          findFirst: {
            args: Prisma.SupplierFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupplierFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplierPayload>
          }
          findMany: {
            args: Prisma.SupplierFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplierPayload>[]
          }
          create: {
            args: Prisma.SupplierCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplierPayload>
          }
          createMany: {
            args: Prisma.SupplierCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.SupplierDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplierPayload>
          }
          update: {
            args: Prisma.SupplierUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplierPayload>
          }
          deleteMany: {
            args: Prisma.SupplierDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.SupplierUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.SupplierUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<SupplierPayload>
          }
          aggregate: {
            args: Prisma.SupplierAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateSupplier>
          }
          groupBy: {
            args: Prisma.SupplierGroupByArgs<ExtArgs>,
            result: $Utils.Optional<SupplierGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupplierCountArgs<ExtArgs>,
            result: $Utils.Optional<SupplierCountAggregateOutputType> | number
          }
        }
      }
      Apoteker: {
        payload: ApotekerPayload<ExtArgs>
        fields: Prisma.ApotekerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ApotekerFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApotekerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ApotekerFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApotekerPayload>
          }
          findFirst: {
            args: Prisma.ApotekerFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApotekerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ApotekerFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApotekerPayload>
          }
          findMany: {
            args: Prisma.ApotekerFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApotekerPayload>[]
          }
          create: {
            args: Prisma.ApotekerCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApotekerPayload>
          }
          createMany: {
            args: Prisma.ApotekerCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ApotekerDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApotekerPayload>
          }
          update: {
            args: Prisma.ApotekerUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApotekerPayload>
          }
          deleteMany: {
            args: Prisma.ApotekerDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ApotekerUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ApotekerUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<ApotekerPayload>
          }
          aggregate: {
            args: Prisma.ApotekerAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateApoteker>
          }
          groupBy: {
            args: Prisma.ApotekerGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ApotekerGroupByOutputType>[]
          }
          count: {
            args: Prisma.ApotekerCountArgs<ExtArgs>,
            result: $Utils.Optional<ApotekerCountAggregateOutputType> | number
          }
        }
      }
      Pelanggan: {
        payload: PelangganPayload<ExtArgs>
        fields: Prisma.PelangganFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PelangganFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PelangganPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PelangganFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PelangganPayload>
          }
          findFirst: {
            args: Prisma.PelangganFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PelangganPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PelangganFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PelangganPayload>
          }
          findMany: {
            args: Prisma.PelangganFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PelangganPayload>[]
          }
          create: {
            args: Prisma.PelangganCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PelangganPayload>
          }
          createMany: {
            args: Prisma.PelangganCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PelangganDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PelangganPayload>
          }
          update: {
            args: Prisma.PelangganUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PelangganPayload>
          }
          deleteMany: {
            args: Prisma.PelangganDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PelangganUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PelangganUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PelangganPayload>
          }
          aggregate: {
            args: Prisma.PelangganAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePelanggan>
          }
          groupBy: {
            args: Prisma.PelangganGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PelangganGroupByOutputType>[]
          }
          count: {
            args: Prisma.PelangganCountArgs<ExtArgs>,
            result: $Utils.Optional<PelangganCountAggregateOutputType> | number
          }
        }
      }
      Laporan: {
        payload: LaporanPayload<ExtArgs>
        fields: Prisma.LaporanFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LaporanFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LaporanPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LaporanFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LaporanPayload>
          }
          findFirst: {
            args: Prisma.LaporanFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LaporanPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LaporanFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LaporanPayload>
          }
          findMany: {
            args: Prisma.LaporanFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LaporanPayload>[]
          }
          create: {
            args: Prisma.LaporanCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LaporanPayload>
          }
          createMany: {
            args: Prisma.LaporanCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.LaporanDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LaporanPayload>
          }
          update: {
            args: Prisma.LaporanUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LaporanPayload>
          }
          deleteMany: {
            args: Prisma.LaporanDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.LaporanUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.LaporanUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<LaporanPayload>
          }
          aggregate: {
            args: Prisma.LaporanAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateLaporan>
          }
          groupBy: {
            args: Prisma.LaporanGroupByArgs<ExtArgs>,
            result: $Utils.Optional<LaporanGroupByOutputType>[]
          }
          count: {
            args: Prisma.LaporanCountArgs<ExtArgs>,
            result: $Utils.Optional<LaporanCountAggregateOutputType> | number
          }
        }
      }
      Pemilik: {
        payload: PemilikPayload<ExtArgs>
        fields: Prisma.PemilikFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PemilikFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PemilikPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PemilikFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PemilikPayload>
          }
          findFirst: {
            args: Prisma.PemilikFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PemilikPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PemilikFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PemilikPayload>
          }
          findMany: {
            args: Prisma.PemilikFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PemilikPayload>[]
          }
          create: {
            args: Prisma.PemilikCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PemilikPayload>
          }
          createMany: {
            args: Prisma.PemilikCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.PemilikDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PemilikPayload>
          }
          update: {
            args: Prisma.PemilikUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PemilikPayload>
          }
          deleteMany: {
            args: Prisma.PemilikDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.PemilikUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.PemilikUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<PemilikPayload>
          }
          aggregate: {
            args: Prisma.PemilikAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregatePemilik>
          }
          groupBy: {
            args: Prisma.PemilikGroupByArgs<ExtArgs>,
            result: $Utils.Optional<PemilikGroupByOutputType>[]
          }
          count: {
            args: Prisma.PemilikCountArgs<ExtArgs>,
            result: $Utils.Optional<PemilikCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ObatCountOutputType
   */


  export type ObatCountOutputType = {
    det_pembelian: number
  }

  export type ObatCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    det_pembelian?: boolean | ObatCountOutputTypeCountDet_pembelianArgs
  }

  // Custom InputTypes

  /**
   * ObatCountOutputType without action
   */
  export type ObatCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ObatCountOutputType
     */
    select?: ObatCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ObatCountOutputType without action
   */
  export type ObatCountOutputTypeCountDet_pembelianArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Det_pembelianWhereInput
  }



  /**
   * Count Type PembelianCountOutputType
   */


  export type PembelianCountOutputType = {
    det_pembelian: number
  }

  export type PembelianCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    det_pembelian?: boolean | PembelianCountOutputTypeCountDet_pembelianArgs
  }

  // Custom InputTypes

  /**
   * PembelianCountOutputType without action
   */
  export type PembelianCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PembelianCountOutputType
     */
    select?: PembelianCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PembelianCountOutputType without action
   */
  export type PembelianCountOutputTypeCountDet_pembelianArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Det_pembelianWhereInput
  }



  /**
   * Count Type Staff_gudangCountOutputType
   */


  export type Staff_gudangCountOutputType = {
    Obat: number
  }

  export type Staff_gudangCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Obat?: boolean | Staff_gudangCountOutputTypeCountObatArgs
  }

  // Custom InputTypes

  /**
   * Staff_gudangCountOutputType without action
   */
  export type Staff_gudangCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff_gudangCountOutputType
     */
    select?: Staff_gudangCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * Staff_gudangCountOutputType without action
   */
  export type Staff_gudangCountOutputTypeCountObatArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ObatWhereInput
  }



  /**
   * Count Type SupplierCountOutputType
   */


  export type SupplierCountOutputType = {
    Obat: number
  }

  export type SupplierCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Obat?: boolean | SupplierCountOutputTypeCountObatArgs
  }

  // Custom InputTypes

  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupplierCountOutputType
     */
    select?: SupplierCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * SupplierCountOutputType without action
   */
  export type SupplierCountOutputTypeCountObatArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ObatWhereInput
  }



  /**
   * Count Type ApotekerCountOutputType
   */


  export type ApotekerCountOutputType = {
    laporan: number
    pembelian: number
  }

  export type ApotekerCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    laporan?: boolean | ApotekerCountOutputTypeCountLaporanArgs
    pembelian?: boolean | ApotekerCountOutputTypeCountPembelianArgs
  }

  // Custom InputTypes

  /**
   * ApotekerCountOutputType without action
   */
  export type ApotekerCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ApotekerCountOutputType
     */
    select?: ApotekerCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * ApotekerCountOutputType without action
   */
  export type ApotekerCountOutputTypeCountLaporanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LaporanWhereInput
  }


  /**
   * ApotekerCountOutputType without action
   */
  export type ApotekerCountOutputTypeCountPembelianArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PembelianWhereInput
  }



  /**
   * Count Type PelangganCountOutputType
   */


  export type PelangganCountOutputType = {
    pembelian: number
  }

  export type PelangganCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pembelian?: boolean | PelangganCountOutputTypeCountPembelianArgs
  }

  // Custom InputTypes

  /**
   * PelangganCountOutputType without action
   */
  export type PelangganCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PelangganCountOutputType
     */
    select?: PelangganCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PelangganCountOutputType without action
   */
  export type PelangganCountOutputTypeCountPembelianArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PembelianWhereInput
  }



  /**
   * Count Type PemilikCountOutputType
   */


  export type PemilikCountOutputType = {
    laporan: number
  }

  export type PemilikCountOutputTypeSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    laporan?: boolean | PemilikCountOutputTypeCountLaporanArgs
  }

  // Custom InputTypes

  /**
   * PemilikCountOutputType without action
   */
  export type PemilikCountOutputTypeArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PemilikCountOutputType
     */
    select?: PemilikCountOutputTypeSelect<ExtArgs> | null
  }


  /**
   * PemilikCountOutputType without action
   */
  export type PemilikCountOutputTypeCountLaporanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LaporanWhereInput
  }



  /**
   * Models
   */

  /**
   * Model Obat
   */


  export type AggregateObat = {
    _count: ObatCountAggregateOutputType | null
    _avg: ObatAvgAggregateOutputType | null
    _sum: ObatSumAggregateOutputType | null
    _min: ObatMinAggregateOutputType | null
    _max: ObatMaxAggregateOutputType | null
  }

  export type ObatAvgAggregateOutputType = {
    jumlah: number | null
    harga_beli: number | null
    harga_jual: number | null
    stok_obat: number | null
  }

  export type ObatSumAggregateOutputType = {
    jumlah: number | null
    harga_beli: number | null
    harga_jual: number | null
    stok_obat: number | null
  }

  export type ObatMinAggregateOutputType = {
    id: string | null
    nama_obat: string | null
    gambar: string | null
    jenis_obat: string | null
    tipe_obat: string | null
    tanggal_expired: string | null
    jumlah: number | null
    harga_beli: number | null
    harga_jual: number | null
    stok_obat: number | null
    kategori_obat: string | null
    sub_kategori: string | null
    created_at: Date | null
    updated_at: Date | null
    id_staff: string | null
    id_supplier: string | null
  }

  export type ObatMaxAggregateOutputType = {
    id: string | null
    nama_obat: string | null
    gambar: string | null
    jenis_obat: string | null
    tipe_obat: string | null
    tanggal_expired: string | null
    jumlah: number | null
    harga_beli: number | null
    harga_jual: number | null
    stok_obat: number | null
    kategori_obat: string | null
    sub_kategori: string | null
    created_at: Date | null
    updated_at: Date | null
    id_staff: string | null
    id_supplier: string | null
  }

  export type ObatCountAggregateOutputType = {
    id: number
    nama_obat: number
    gambar: number
    jenis_obat: number
    tipe_obat: number
    tanggal_expired: number
    jumlah: number
    harga_beli: number
    harga_jual: number
    stok_obat: number
    kategori_obat: number
    sub_kategori: number
    created_at: number
    updated_at: number
    id_staff: number
    id_supplier: number
    _all: number
  }


  export type ObatAvgAggregateInputType = {
    jumlah?: true
    harga_beli?: true
    harga_jual?: true
    stok_obat?: true
  }

  export type ObatSumAggregateInputType = {
    jumlah?: true
    harga_beli?: true
    harga_jual?: true
    stok_obat?: true
  }

  export type ObatMinAggregateInputType = {
    id?: true
    nama_obat?: true
    gambar?: true
    jenis_obat?: true
    tipe_obat?: true
    tanggal_expired?: true
    jumlah?: true
    harga_beli?: true
    harga_jual?: true
    stok_obat?: true
    kategori_obat?: true
    sub_kategori?: true
    created_at?: true
    updated_at?: true
    id_staff?: true
    id_supplier?: true
  }

  export type ObatMaxAggregateInputType = {
    id?: true
    nama_obat?: true
    gambar?: true
    jenis_obat?: true
    tipe_obat?: true
    tanggal_expired?: true
    jumlah?: true
    harga_beli?: true
    harga_jual?: true
    stok_obat?: true
    kategori_obat?: true
    sub_kategori?: true
    created_at?: true
    updated_at?: true
    id_staff?: true
    id_supplier?: true
  }

  export type ObatCountAggregateInputType = {
    id?: true
    nama_obat?: true
    gambar?: true
    jenis_obat?: true
    tipe_obat?: true
    tanggal_expired?: true
    jumlah?: true
    harga_beli?: true
    harga_jual?: true
    stok_obat?: true
    kategori_obat?: true
    sub_kategori?: true
    created_at?: true
    updated_at?: true
    id_staff?: true
    id_supplier?: true
    _all?: true
  }

  export type ObatAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Obat to aggregate.
     */
    where?: ObatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obats to fetch.
     */
    orderBy?: ObatOrderByWithRelationInput | ObatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ObatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Obats
    **/
    _count?: true | ObatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ObatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ObatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ObatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ObatMaxAggregateInputType
  }

  export type GetObatAggregateType<T extends ObatAggregateArgs> = {
        [P in keyof T & keyof AggregateObat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateObat[P]>
      : GetScalarType<T[P], AggregateObat[P]>
  }




  export type ObatGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ObatWhereInput
    orderBy?: ObatOrderByWithAggregationInput | ObatOrderByWithAggregationInput[]
    by: ObatScalarFieldEnum[] | ObatScalarFieldEnum
    having?: ObatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ObatCountAggregateInputType | true
    _avg?: ObatAvgAggregateInputType
    _sum?: ObatSumAggregateInputType
    _min?: ObatMinAggregateInputType
    _max?: ObatMaxAggregateInputType
  }


  export type ObatGroupByOutputType = {
    id: string
    nama_obat: string | null
    gambar: string | null
    jenis_obat: string | null
    tipe_obat: string | null
    tanggal_expired: string | null
    jumlah: number | null
    harga_beli: number
    harga_jual: number
    stok_obat: number | null
    kategori_obat: string | null
    sub_kategori: string | null
    created_at: Date
    updated_at: Date
    id_staff: string
    id_supplier: string
    _count: ObatCountAggregateOutputType | null
    _avg: ObatAvgAggregateOutputType | null
    _sum: ObatSumAggregateOutputType | null
    _min: ObatMinAggregateOutputType | null
    _max: ObatMaxAggregateOutputType | null
  }

  type GetObatGroupByPayload<T extends ObatGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ObatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ObatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ObatGroupByOutputType[P]>
            : GetScalarType<T[P], ObatGroupByOutputType[P]>
        }
      >
    >


  export type ObatSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama_obat?: boolean
    gambar?: boolean
    jenis_obat?: boolean
    tipe_obat?: boolean
    tanggal_expired?: boolean
    jumlah?: boolean
    harga_beli?: boolean
    harga_jual?: boolean
    stok_obat?: boolean
    kategori_obat?: boolean
    sub_kategori?: boolean
    created_at?: boolean
    updated_at?: boolean
    id_staff?: boolean
    id_supplier?: boolean
    staff?: boolean | Staff_gudangArgs<ExtArgs>
    supplier?: boolean | SupplierArgs<ExtArgs>
    det_pembelian?: boolean | Obat$det_pembelianArgs<ExtArgs>
    _count?: boolean | ObatCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["obat"]>

  export type ObatSelectScalar = {
    id?: boolean
    nama_obat?: boolean
    gambar?: boolean
    jenis_obat?: boolean
    tipe_obat?: boolean
    tanggal_expired?: boolean
    jumlah?: boolean
    harga_beli?: boolean
    harga_jual?: boolean
    stok_obat?: boolean
    kategori_obat?: boolean
    sub_kategori?: boolean
    created_at?: boolean
    updated_at?: boolean
    id_staff?: boolean
    id_supplier?: boolean
  }

  export type ObatInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    staff?: boolean | Staff_gudangArgs<ExtArgs>
    supplier?: boolean | SupplierArgs<ExtArgs>
    det_pembelian?: boolean | Obat$det_pembelianArgs<ExtArgs>
    _count?: boolean | ObatCountOutputTypeArgs<ExtArgs>
  }


  type ObatGetPayload<S extends boolean | null | undefined | ObatArgs> = $Types.GetResult<ObatPayload, S>

  type ObatCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ObatFindManyArgs, 'select' | 'include'> & {
      select?: ObatCountAggregateInputType | true
    }

  export interface ObatDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Obat'], meta: { name: 'Obat' } }
    /**
     * Find zero or one Obat that matches the filter.
     * @param {ObatFindUniqueArgs} args - Arguments to find a Obat
     * @example
     * // Get one Obat
     * const obat = await prisma.obat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ObatFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ObatFindUniqueArgs<ExtArgs>>
    ): Prisma__ObatClient<$Types.GetResult<ObatPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Obat that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ObatFindUniqueOrThrowArgs} args - Arguments to find a Obat
     * @example
     * // Get one Obat
     * const obat = await prisma.obat.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ObatFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObatFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ObatClient<$Types.GetResult<ObatPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Obat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObatFindFirstArgs} args - Arguments to find a Obat
     * @example
     * // Get one Obat
     * const obat = await prisma.obat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ObatFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ObatFindFirstArgs<ExtArgs>>
    ): Prisma__ObatClient<$Types.GetResult<ObatPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Obat that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObatFindFirstOrThrowArgs} args - Arguments to find a Obat
     * @example
     * // Get one Obat
     * const obat = await prisma.obat.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ObatFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ObatFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ObatClient<$Types.GetResult<ObatPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Obats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Obats
     * const obats = await prisma.obat.findMany()
     * 
     * // Get first 10 Obats
     * const obats = await prisma.obat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const obatWithIdOnly = await prisma.obat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ObatFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObatFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ObatPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Obat.
     * @param {ObatCreateArgs} args - Arguments to create a Obat.
     * @example
     * // Create one Obat
     * const Obat = await prisma.obat.create({
     *   data: {
     *     // ... data to create a Obat
     *   }
     * })
     * 
    **/
    create<T extends ObatCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ObatCreateArgs<ExtArgs>>
    ): Prisma__ObatClient<$Types.GetResult<ObatPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Obats.
     *     @param {ObatCreateManyArgs} args - Arguments to create many Obats.
     *     @example
     *     // Create many Obats
     *     const obat = await prisma.obat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ObatCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObatCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Obat.
     * @param {ObatDeleteArgs} args - Arguments to delete one Obat.
     * @example
     * // Delete one Obat
     * const Obat = await prisma.obat.delete({
     *   where: {
     *     // ... filter to delete one Obat
     *   }
     * })
     * 
    **/
    delete<T extends ObatDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ObatDeleteArgs<ExtArgs>>
    ): Prisma__ObatClient<$Types.GetResult<ObatPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Obat.
     * @param {ObatUpdateArgs} args - Arguments to update one Obat.
     * @example
     * // Update one Obat
     * const obat = await prisma.obat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ObatUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ObatUpdateArgs<ExtArgs>>
    ): Prisma__ObatClient<$Types.GetResult<ObatPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Obats.
     * @param {ObatDeleteManyArgs} args - Arguments to filter Obats to delete.
     * @example
     * // Delete a few Obats
     * const { count } = await prisma.obat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ObatDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ObatDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Obats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Obats
     * const obat = await prisma.obat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ObatUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ObatUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Obat.
     * @param {ObatUpsertArgs} args - Arguments to update or create a Obat.
     * @example
     * // Update or create a Obat
     * const obat = await prisma.obat.upsert({
     *   create: {
     *     // ... data to create a Obat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Obat we want to update
     *   }
     * })
    **/
    upsert<T extends ObatUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ObatUpsertArgs<ExtArgs>>
    ): Prisma__ObatClient<$Types.GetResult<ObatPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Obats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObatCountArgs} args - Arguments to filter Obats to count.
     * @example
     * // Count the number of Obats
     * const count = await prisma.obat.count({
     *   where: {
     *     // ... the filter for the Obats we want to count
     *   }
     * })
    **/
    count<T extends ObatCountArgs>(
      args?: Subset<T, ObatCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ObatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Obat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ObatAggregateArgs>(args: Subset<T, ObatAggregateArgs>): Prisma.PrismaPromise<GetObatAggregateType<T>>

    /**
     * Group by Obat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ObatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ObatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ObatGroupByArgs['orderBy'] }
        : { orderBy?: ObatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ObatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetObatGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Obat model
   */
  readonly fields: ObatFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Obat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ObatClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    staff<T extends Staff_gudangArgs<ExtArgs> = {}>(args?: Subset<T, Staff_gudangArgs<ExtArgs>>): Prisma__Staff_gudangClient<$Types.GetResult<Staff_gudangPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    supplier<T extends SupplierArgs<ExtArgs> = {}>(args?: Subset<T, SupplierArgs<ExtArgs>>): Prisma__SupplierClient<$Types.GetResult<SupplierPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    det_pembelian<T extends Obat$det_pembelianArgs<ExtArgs> = {}>(args?: Subset<T, Obat$det_pembelianArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<Det_pembelianPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Obat model
   */ 
  interface ObatFieldRefs {
    readonly id: FieldRef<"Obat", 'String'>
    readonly nama_obat: FieldRef<"Obat", 'String'>
    readonly gambar: FieldRef<"Obat", 'String'>
    readonly jenis_obat: FieldRef<"Obat", 'String'>
    readonly tipe_obat: FieldRef<"Obat", 'String'>
    readonly tanggal_expired: FieldRef<"Obat", 'String'>
    readonly jumlah: FieldRef<"Obat", 'Int'>
    readonly harga_beli: FieldRef<"Obat", 'Int'>
    readonly harga_jual: FieldRef<"Obat", 'Int'>
    readonly stok_obat: FieldRef<"Obat", 'Int'>
    readonly kategori_obat: FieldRef<"Obat", 'String'>
    readonly sub_kategori: FieldRef<"Obat", 'String'>
    readonly created_at: FieldRef<"Obat", 'DateTime'>
    readonly updated_at: FieldRef<"Obat", 'DateTime'>
    readonly id_staff: FieldRef<"Obat", 'String'>
    readonly id_supplier: FieldRef<"Obat", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Obat findUnique
   */
  export type ObatFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
    /**
     * Filter, which Obat to fetch.
     */
    where: ObatWhereUniqueInput
  }


  /**
   * Obat findUniqueOrThrow
   */
  export type ObatFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
    /**
     * Filter, which Obat to fetch.
     */
    where: ObatWhereUniqueInput
  }


  /**
   * Obat findFirst
   */
  export type ObatFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
    /**
     * Filter, which Obat to fetch.
     */
    where?: ObatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obats to fetch.
     */
    orderBy?: ObatOrderByWithRelationInput | ObatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Obats.
     */
    cursor?: ObatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Obats.
     */
    distinct?: ObatScalarFieldEnum | ObatScalarFieldEnum[]
  }


  /**
   * Obat findFirstOrThrow
   */
  export type ObatFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
    /**
     * Filter, which Obat to fetch.
     */
    where?: ObatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obats to fetch.
     */
    orderBy?: ObatOrderByWithRelationInput | ObatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Obats.
     */
    cursor?: ObatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obats.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Obats.
     */
    distinct?: ObatScalarFieldEnum | ObatScalarFieldEnum[]
  }


  /**
   * Obat findMany
   */
  export type ObatFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
    /**
     * Filter, which Obats to fetch.
     */
    where?: ObatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Obats to fetch.
     */
    orderBy?: ObatOrderByWithRelationInput | ObatOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Obats.
     */
    cursor?: ObatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Obats from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Obats.
     */
    skip?: number
    distinct?: ObatScalarFieldEnum | ObatScalarFieldEnum[]
  }


  /**
   * Obat create
   */
  export type ObatCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
    /**
     * The data needed to create a Obat.
     */
    data: XOR<ObatCreateInput, ObatUncheckedCreateInput>
  }


  /**
   * Obat createMany
   */
  export type ObatCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Obats.
     */
    data: ObatCreateManyInput | ObatCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Obat update
   */
  export type ObatUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
    /**
     * The data needed to update a Obat.
     */
    data: XOR<ObatUpdateInput, ObatUncheckedUpdateInput>
    /**
     * Choose, which Obat to update.
     */
    where: ObatWhereUniqueInput
  }


  /**
   * Obat updateMany
   */
  export type ObatUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Obats.
     */
    data: XOR<ObatUpdateManyMutationInput, ObatUncheckedUpdateManyInput>
    /**
     * Filter which Obats to update
     */
    where?: ObatWhereInput
  }


  /**
   * Obat upsert
   */
  export type ObatUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
    /**
     * The filter to search for the Obat to update in case it exists.
     */
    where: ObatWhereUniqueInput
    /**
     * In case the Obat found by the `where` argument doesn't exist, create a new Obat with this data.
     */
    create: XOR<ObatCreateInput, ObatUncheckedCreateInput>
    /**
     * In case the Obat was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ObatUpdateInput, ObatUncheckedUpdateInput>
  }


  /**
   * Obat delete
   */
  export type ObatDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
    /**
     * Filter which Obat to delete.
     */
    where: ObatWhereUniqueInput
  }


  /**
   * Obat deleteMany
   */
  export type ObatDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Obats to delete
     */
    where?: ObatWhereInput
  }


  /**
   * Obat.det_pembelian
   */
  export type Obat$det_pembelianArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
    where?: Det_pembelianWhereInput
    orderBy?: Det_pembelianOrderByWithRelationInput | Det_pembelianOrderByWithRelationInput[]
    cursor?: Det_pembelianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Det_pembelianScalarFieldEnum | Det_pembelianScalarFieldEnum[]
  }


  /**
   * Obat without action
   */
  export type ObatArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
  }



  /**
   * Model Pembelian
   */


  export type AggregatePembelian = {
    _count: PembelianCountAggregateOutputType | null
    _avg: PembelianAvgAggregateOutputType | null
    _sum: PembelianSumAggregateOutputType | null
    _min: PembelianMinAggregateOutputType | null
    _max: PembelianMaxAggregateOutputType | null
  }

  export type PembelianAvgAggregateOutputType = {
    jumlah_jual: number | null
    total_harga: number | null
  }

  export type PembelianSumAggregateOutputType = {
    jumlah_jual: number | null
    total_harga: number | null
  }

  export type PembelianMinAggregateOutputType = {
    id: string | null
    jumlah_jual: number | null
    total_harga: number | null
    tanggal_beli: Date | null
    jumlah_beli: string | null
    id_pelanggan: string | null
    id_apoteker: string | null
  }

  export type PembelianMaxAggregateOutputType = {
    id: string | null
    jumlah_jual: number | null
    total_harga: number | null
    tanggal_beli: Date | null
    jumlah_beli: string | null
    id_pelanggan: string | null
    id_apoteker: string | null
  }

  export type PembelianCountAggregateOutputType = {
    id: number
    jumlah_jual: number
    total_harga: number
    tanggal_beli: number
    jumlah_beli: number
    id_pelanggan: number
    id_apoteker: number
    _all: number
  }


  export type PembelianAvgAggregateInputType = {
    jumlah_jual?: true
    total_harga?: true
  }

  export type PembelianSumAggregateInputType = {
    jumlah_jual?: true
    total_harga?: true
  }

  export type PembelianMinAggregateInputType = {
    id?: true
    jumlah_jual?: true
    total_harga?: true
    tanggal_beli?: true
    jumlah_beli?: true
    id_pelanggan?: true
    id_apoteker?: true
  }

  export type PembelianMaxAggregateInputType = {
    id?: true
    jumlah_jual?: true
    total_harga?: true
    tanggal_beli?: true
    jumlah_beli?: true
    id_pelanggan?: true
    id_apoteker?: true
  }

  export type PembelianCountAggregateInputType = {
    id?: true
    jumlah_jual?: true
    total_harga?: true
    tanggal_beli?: true
    jumlah_beli?: true
    id_pelanggan?: true
    id_apoteker?: true
    _all?: true
  }

  export type PembelianAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pembelian to aggregate.
     */
    where?: PembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembelians to fetch.
     */
    orderBy?: PembelianOrderByWithRelationInput | PembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembelians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pembelians
    **/
    _count?: true | PembelianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PembelianAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PembelianSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PembelianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PembelianMaxAggregateInputType
  }

  export type GetPembelianAggregateType<T extends PembelianAggregateArgs> = {
        [P in keyof T & keyof AggregatePembelian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePembelian[P]>
      : GetScalarType<T[P], AggregatePembelian[P]>
  }




  export type PembelianGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PembelianWhereInput
    orderBy?: PembelianOrderByWithAggregationInput | PembelianOrderByWithAggregationInput[]
    by: PembelianScalarFieldEnum[] | PembelianScalarFieldEnum
    having?: PembelianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PembelianCountAggregateInputType | true
    _avg?: PembelianAvgAggregateInputType
    _sum?: PembelianSumAggregateInputType
    _min?: PembelianMinAggregateInputType
    _max?: PembelianMaxAggregateInputType
  }


  export type PembelianGroupByOutputType = {
    id: string
    jumlah_jual: number | null
    total_harga: number
    tanggal_beli: Date | null
    jumlah_beli: string | null
    id_pelanggan: string
    id_apoteker: string
    _count: PembelianCountAggregateOutputType | null
    _avg: PembelianAvgAggregateOutputType | null
    _sum: PembelianSumAggregateOutputType | null
    _min: PembelianMinAggregateOutputType | null
    _max: PembelianMaxAggregateOutputType | null
  }

  type GetPembelianGroupByPayload<T extends PembelianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PembelianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PembelianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PembelianGroupByOutputType[P]>
            : GetScalarType<T[P], PembelianGroupByOutputType[P]>
        }
      >
    >


  export type PembelianSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    jumlah_jual?: boolean
    total_harga?: boolean
    tanggal_beli?: boolean
    jumlah_beli?: boolean
    id_pelanggan?: boolean
    id_apoteker?: boolean
    pelanggan?: boolean | PelangganArgs<ExtArgs>
    apoteker?: boolean | ApotekerArgs<ExtArgs>
    det_pembelian?: boolean | Pembelian$det_pembelianArgs<ExtArgs>
    _count?: boolean | PembelianCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["pembelian"]>

  export type PembelianSelectScalar = {
    id?: boolean
    jumlah_jual?: boolean
    total_harga?: boolean
    tanggal_beli?: boolean
    jumlah_beli?: boolean
    id_pelanggan?: boolean
    id_apoteker?: boolean
  }

  export type PembelianInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pelanggan?: boolean | PelangganArgs<ExtArgs>
    apoteker?: boolean | ApotekerArgs<ExtArgs>
    det_pembelian?: boolean | Pembelian$det_pembelianArgs<ExtArgs>
    _count?: boolean | PembelianCountOutputTypeArgs<ExtArgs>
  }


  type PembelianGetPayload<S extends boolean | null | undefined | PembelianArgs> = $Types.GetResult<PembelianPayload, S>

  type PembelianCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PembelianFindManyArgs, 'select' | 'include'> & {
      select?: PembelianCountAggregateInputType | true
    }

  export interface PembelianDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pembelian'], meta: { name: 'Pembelian' } }
    /**
     * Find zero or one Pembelian that matches the filter.
     * @param {PembelianFindUniqueArgs} args - Arguments to find a Pembelian
     * @example
     * // Get one Pembelian
     * const pembelian = await prisma.pembelian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PembelianFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PembelianFindUniqueArgs<ExtArgs>>
    ): Prisma__PembelianClient<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pembelian that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PembelianFindUniqueOrThrowArgs} args - Arguments to find a Pembelian
     * @example
     * // Get one Pembelian
     * const pembelian = await prisma.pembelian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PembelianFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PembelianFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PembelianClient<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pembelian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembelianFindFirstArgs} args - Arguments to find a Pembelian
     * @example
     * // Get one Pembelian
     * const pembelian = await prisma.pembelian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PembelianFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PembelianFindFirstArgs<ExtArgs>>
    ): Prisma__PembelianClient<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pembelian that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembelianFindFirstOrThrowArgs} args - Arguments to find a Pembelian
     * @example
     * // Get one Pembelian
     * const pembelian = await prisma.pembelian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PembelianFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PembelianFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PembelianClient<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pembelians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembelianFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pembelians
     * const pembelians = await prisma.pembelian.findMany()
     * 
     * // Get first 10 Pembelians
     * const pembelians = await prisma.pembelian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pembelianWithIdOnly = await prisma.pembelian.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PembelianFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PembelianFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pembelian.
     * @param {PembelianCreateArgs} args - Arguments to create a Pembelian.
     * @example
     * // Create one Pembelian
     * const Pembelian = await prisma.pembelian.create({
     *   data: {
     *     // ... data to create a Pembelian
     *   }
     * })
     * 
    **/
    create<T extends PembelianCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PembelianCreateArgs<ExtArgs>>
    ): Prisma__PembelianClient<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pembelians.
     *     @param {PembelianCreateManyArgs} args - Arguments to create many Pembelians.
     *     @example
     *     // Create many Pembelians
     *     const pembelian = await prisma.pembelian.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PembelianCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PembelianCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pembelian.
     * @param {PembelianDeleteArgs} args - Arguments to delete one Pembelian.
     * @example
     * // Delete one Pembelian
     * const Pembelian = await prisma.pembelian.delete({
     *   where: {
     *     // ... filter to delete one Pembelian
     *   }
     * })
     * 
    **/
    delete<T extends PembelianDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PembelianDeleteArgs<ExtArgs>>
    ): Prisma__PembelianClient<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pembelian.
     * @param {PembelianUpdateArgs} args - Arguments to update one Pembelian.
     * @example
     * // Update one Pembelian
     * const pembelian = await prisma.pembelian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PembelianUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PembelianUpdateArgs<ExtArgs>>
    ): Prisma__PembelianClient<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pembelians.
     * @param {PembelianDeleteManyArgs} args - Arguments to filter Pembelians to delete.
     * @example
     * // Delete a few Pembelians
     * const { count } = await prisma.pembelian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PembelianDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PembelianDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pembelians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembelianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pembelians
     * const pembelian = await prisma.pembelian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PembelianUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PembelianUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pembelian.
     * @param {PembelianUpsertArgs} args - Arguments to update or create a Pembelian.
     * @example
     * // Update or create a Pembelian
     * const pembelian = await prisma.pembelian.upsert({
     *   create: {
     *     // ... data to create a Pembelian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pembelian we want to update
     *   }
     * })
    **/
    upsert<T extends PembelianUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PembelianUpsertArgs<ExtArgs>>
    ): Prisma__PembelianClient<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pembelians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembelianCountArgs} args - Arguments to filter Pembelians to count.
     * @example
     * // Count the number of Pembelians
     * const count = await prisma.pembelian.count({
     *   where: {
     *     // ... the filter for the Pembelians we want to count
     *   }
     * })
    **/
    count<T extends PembelianCountArgs>(
      args?: Subset<T, PembelianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PembelianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pembelian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembelianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PembelianAggregateArgs>(args: Subset<T, PembelianAggregateArgs>): Prisma.PrismaPromise<GetPembelianAggregateType<T>>

    /**
     * Group by Pembelian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PembelianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PembelianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PembelianGroupByArgs['orderBy'] }
        : { orderBy?: PembelianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PembelianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPembelianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pembelian model
   */
  readonly fields: PembelianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pembelian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PembelianClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    pelanggan<T extends PelangganArgs<ExtArgs> = {}>(args?: Subset<T, PelangganArgs<ExtArgs>>): Prisma__PelangganClient<$Types.GetResult<PelangganPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    apoteker<T extends ApotekerArgs<ExtArgs> = {}>(args?: Subset<T, ApotekerArgs<ExtArgs>>): Prisma__ApotekerClient<$Types.GetResult<ApotekerPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    det_pembelian<T extends Pembelian$det_pembelianArgs<ExtArgs> = {}>(args?: Subset<T, Pembelian$det_pembelianArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<Det_pembelianPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Pembelian model
   */ 
  interface PembelianFieldRefs {
    readonly id: FieldRef<"Pembelian", 'String'>
    readonly jumlah_jual: FieldRef<"Pembelian", 'Int'>
    readonly total_harga: FieldRef<"Pembelian", 'Int'>
    readonly tanggal_beli: FieldRef<"Pembelian", 'DateTime'>
    readonly jumlah_beli: FieldRef<"Pembelian", 'String'>
    readonly id_pelanggan: FieldRef<"Pembelian", 'String'>
    readonly id_apoteker: FieldRef<"Pembelian", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Pembelian findUnique
   */
  export type PembelianFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
    /**
     * Filter, which Pembelian to fetch.
     */
    where: PembelianWhereUniqueInput
  }


  /**
   * Pembelian findUniqueOrThrow
   */
  export type PembelianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
    /**
     * Filter, which Pembelian to fetch.
     */
    where: PembelianWhereUniqueInput
  }


  /**
   * Pembelian findFirst
   */
  export type PembelianFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
    /**
     * Filter, which Pembelian to fetch.
     */
    where?: PembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembelians to fetch.
     */
    orderBy?: PembelianOrderByWithRelationInput | PembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pembelians.
     */
    cursor?: PembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembelians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pembelians.
     */
    distinct?: PembelianScalarFieldEnum | PembelianScalarFieldEnum[]
  }


  /**
   * Pembelian findFirstOrThrow
   */
  export type PembelianFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
    /**
     * Filter, which Pembelian to fetch.
     */
    where?: PembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembelians to fetch.
     */
    orderBy?: PembelianOrderByWithRelationInput | PembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pembelians.
     */
    cursor?: PembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembelians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pembelians.
     */
    distinct?: PembelianScalarFieldEnum | PembelianScalarFieldEnum[]
  }


  /**
   * Pembelian findMany
   */
  export type PembelianFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
    /**
     * Filter, which Pembelians to fetch.
     */
    where?: PembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pembelians to fetch.
     */
    orderBy?: PembelianOrderByWithRelationInput | PembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pembelians.
     */
    cursor?: PembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pembelians.
     */
    skip?: number
    distinct?: PembelianScalarFieldEnum | PembelianScalarFieldEnum[]
  }


  /**
   * Pembelian create
   */
  export type PembelianCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
    /**
     * The data needed to create a Pembelian.
     */
    data: XOR<PembelianCreateInput, PembelianUncheckedCreateInput>
  }


  /**
   * Pembelian createMany
   */
  export type PembelianCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pembelians.
     */
    data: PembelianCreateManyInput | PembelianCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Pembelian update
   */
  export type PembelianUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
    /**
     * The data needed to update a Pembelian.
     */
    data: XOR<PembelianUpdateInput, PembelianUncheckedUpdateInput>
    /**
     * Choose, which Pembelian to update.
     */
    where: PembelianWhereUniqueInput
  }


  /**
   * Pembelian updateMany
   */
  export type PembelianUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pembelians.
     */
    data: XOR<PembelianUpdateManyMutationInput, PembelianUncheckedUpdateManyInput>
    /**
     * Filter which Pembelians to update
     */
    where?: PembelianWhereInput
  }


  /**
   * Pembelian upsert
   */
  export type PembelianUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
    /**
     * The filter to search for the Pembelian to update in case it exists.
     */
    where: PembelianWhereUniqueInput
    /**
     * In case the Pembelian found by the `where` argument doesn't exist, create a new Pembelian with this data.
     */
    create: XOR<PembelianCreateInput, PembelianUncheckedCreateInput>
    /**
     * In case the Pembelian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PembelianUpdateInput, PembelianUncheckedUpdateInput>
  }


  /**
   * Pembelian delete
   */
  export type PembelianDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
    /**
     * Filter which Pembelian to delete.
     */
    where: PembelianWhereUniqueInput
  }


  /**
   * Pembelian deleteMany
   */
  export type PembelianDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pembelians to delete
     */
    where?: PembelianWhereInput
  }


  /**
   * Pembelian.det_pembelian
   */
  export type Pembelian$det_pembelianArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
    where?: Det_pembelianWhereInput
    orderBy?: Det_pembelianOrderByWithRelationInput | Det_pembelianOrderByWithRelationInput[]
    cursor?: Det_pembelianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Det_pembelianScalarFieldEnum | Det_pembelianScalarFieldEnum[]
  }


  /**
   * Pembelian without action
   */
  export type PembelianArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
  }



  /**
   * Model Det_pembelian
   */


  export type AggregateDet_pembelian = {
    _count: Det_pembelianCountAggregateOutputType | null
    _min: Det_pembelianMinAggregateOutputType | null
    _max: Det_pembelianMaxAggregateOutputType | null
  }

  export type Det_pembelianMinAggregateOutputType = {
    id: string | null
    id_faktur: string | null
    id_obat: string | null
  }

  export type Det_pembelianMaxAggregateOutputType = {
    id: string | null
    id_faktur: string | null
    id_obat: string | null
  }

  export type Det_pembelianCountAggregateOutputType = {
    id: number
    id_faktur: number
    id_obat: number
    _all: number
  }


  export type Det_pembelianMinAggregateInputType = {
    id?: true
    id_faktur?: true
    id_obat?: true
  }

  export type Det_pembelianMaxAggregateInputType = {
    id?: true
    id_faktur?: true
    id_obat?: true
  }

  export type Det_pembelianCountAggregateInputType = {
    id?: true
    id_faktur?: true
    id_obat?: true
    _all?: true
  }

  export type Det_pembelianAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Det_pembelian to aggregate.
     */
    where?: Det_pembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Det_pembelians to fetch.
     */
    orderBy?: Det_pembelianOrderByWithRelationInput | Det_pembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Det_pembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Det_pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Det_pembelians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Det_pembelians
    **/
    _count?: true | Det_pembelianCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Det_pembelianMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Det_pembelianMaxAggregateInputType
  }

  export type GetDet_pembelianAggregateType<T extends Det_pembelianAggregateArgs> = {
        [P in keyof T & keyof AggregateDet_pembelian]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDet_pembelian[P]>
      : GetScalarType<T[P], AggregateDet_pembelian[P]>
  }




  export type Det_pembelianGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Det_pembelianWhereInput
    orderBy?: Det_pembelianOrderByWithAggregationInput | Det_pembelianOrderByWithAggregationInput[]
    by: Det_pembelianScalarFieldEnum[] | Det_pembelianScalarFieldEnum
    having?: Det_pembelianScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Det_pembelianCountAggregateInputType | true
    _min?: Det_pembelianMinAggregateInputType
    _max?: Det_pembelianMaxAggregateInputType
  }


  export type Det_pembelianGroupByOutputType = {
    id: string
    id_faktur: string
    id_obat: string
    _count: Det_pembelianCountAggregateOutputType | null
    _min: Det_pembelianMinAggregateOutputType | null
    _max: Det_pembelianMaxAggregateOutputType | null
  }

  type GetDet_pembelianGroupByPayload<T extends Det_pembelianGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Det_pembelianGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Det_pembelianGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Det_pembelianGroupByOutputType[P]>
            : GetScalarType<T[P], Det_pembelianGroupByOutputType[P]>
        }
      >
    >


  export type Det_pembelianSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    id_faktur?: boolean
    id_obat?: boolean
    pembelian?: boolean | PembelianArgs<ExtArgs>
    obat?: boolean | ObatArgs<ExtArgs>
  }, ExtArgs["result"]["det_pembelian"]>

  export type Det_pembelianSelectScalar = {
    id?: boolean
    id_faktur?: boolean
    id_obat?: boolean
  }

  export type Det_pembelianInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pembelian?: boolean | PembelianArgs<ExtArgs>
    obat?: boolean | ObatArgs<ExtArgs>
  }


  type Det_pembelianGetPayload<S extends boolean | null | undefined | Det_pembelianArgs> = $Types.GetResult<Det_pembelianPayload, S>

  type Det_pembelianCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<Det_pembelianFindManyArgs, 'select' | 'include'> & {
      select?: Det_pembelianCountAggregateInputType | true
    }

  export interface Det_pembelianDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Det_pembelian'], meta: { name: 'Det_pembelian' } }
    /**
     * Find zero or one Det_pembelian that matches the filter.
     * @param {Det_pembelianFindUniqueArgs} args - Arguments to find a Det_pembelian
     * @example
     * // Get one Det_pembelian
     * const det_pembelian = await prisma.det_pembelian.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Det_pembelianFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Det_pembelianFindUniqueArgs<ExtArgs>>
    ): Prisma__Det_pembelianClient<$Types.GetResult<Det_pembelianPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Det_pembelian that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Det_pembelianFindUniqueOrThrowArgs} args - Arguments to find a Det_pembelian
     * @example
     * // Get one Det_pembelian
     * const det_pembelian = await prisma.det_pembelian.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Det_pembelianFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Det_pembelianFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Det_pembelianClient<$Types.GetResult<Det_pembelianPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Det_pembelian that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Det_pembelianFindFirstArgs} args - Arguments to find a Det_pembelian
     * @example
     * // Get one Det_pembelian
     * const det_pembelian = await prisma.det_pembelian.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Det_pembelianFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Det_pembelianFindFirstArgs<ExtArgs>>
    ): Prisma__Det_pembelianClient<$Types.GetResult<Det_pembelianPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Det_pembelian that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Det_pembelianFindFirstOrThrowArgs} args - Arguments to find a Det_pembelian
     * @example
     * // Get one Det_pembelian
     * const det_pembelian = await prisma.det_pembelian.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Det_pembelianFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Det_pembelianFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Det_pembelianClient<$Types.GetResult<Det_pembelianPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Det_pembelians that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Det_pembelianFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Det_pembelians
     * const det_pembelians = await prisma.det_pembelian.findMany()
     * 
     * // Get first 10 Det_pembelians
     * const det_pembelians = await prisma.det_pembelian.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const det_pembelianWithIdOnly = await prisma.det_pembelian.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Det_pembelianFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Det_pembelianFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<Det_pembelianPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Det_pembelian.
     * @param {Det_pembelianCreateArgs} args - Arguments to create a Det_pembelian.
     * @example
     * // Create one Det_pembelian
     * const Det_pembelian = await prisma.det_pembelian.create({
     *   data: {
     *     // ... data to create a Det_pembelian
     *   }
     * })
     * 
    **/
    create<T extends Det_pembelianCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Det_pembelianCreateArgs<ExtArgs>>
    ): Prisma__Det_pembelianClient<$Types.GetResult<Det_pembelianPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Det_pembelians.
     *     @param {Det_pembelianCreateManyArgs} args - Arguments to create many Det_pembelians.
     *     @example
     *     // Create many Det_pembelians
     *     const det_pembelian = await prisma.det_pembelian.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Det_pembelianCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Det_pembelianCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Det_pembelian.
     * @param {Det_pembelianDeleteArgs} args - Arguments to delete one Det_pembelian.
     * @example
     * // Delete one Det_pembelian
     * const Det_pembelian = await prisma.det_pembelian.delete({
     *   where: {
     *     // ... filter to delete one Det_pembelian
     *   }
     * })
     * 
    **/
    delete<T extends Det_pembelianDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Det_pembelianDeleteArgs<ExtArgs>>
    ): Prisma__Det_pembelianClient<$Types.GetResult<Det_pembelianPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Det_pembelian.
     * @param {Det_pembelianUpdateArgs} args - Arguments to update one Det_pembelian.
     * @example
     * // Update one Det_pembelian
     * const det_pembelian = await prisma.det_pembelian.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Det_pembelianUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Det_pembelianUpdateArgs<ExtArgs>>
    ): Prisma__Det_pembelianClient<$Types.GetResult<Det_pembelianPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Det_pembelians.
     * @param {Det_pembelianDeleteManyArgs} args - Arguments to filter Det_pembelians to delete.
     * @example
     * // Delete a few Det_pembelians
     * const { count } = await prisma.det_pembelian.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Det_pembelianDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Det_pembelianDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Det_pembelians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Det_pembelianUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Det_pembelians
     * const det_pembelian = await prisma.det_pembelian.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Det_pembelianUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Det_pembelianUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Det_pembelian.
     * @param {Det_pembelianUpsertArgs} args - Arguments to update or create a Det_pembelian.
     * @example
     * // Update or create a Det_pembelian
     * const det_pembelian = await prisma.det_pembelian.upsert({
     *   create: {
     *     // ... data to create a Det_pembelian
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Det_pembelian we want to update
     *   }
     * })
    **/
    upsert<T extends Det_pembelianUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Det_pembelianUpsertArgs<ExtArgs>>
    ): Prisma__Det_pembelianClient<$Types.GetResult<Det_pembelianPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Det_pembelians.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Det_pembelianCountArgs} args - Arguments to filter Det_pembelians to count.
     * @example
     * // Count the number of Det_pembelians
     * const count = await prisma.det_pembelian.count({
     *   where: {
     *     // ... the filter for the Det_pembelians we want to count
     *   }
     * })
    **/
    count<T extends Det_pembelianCountArgs>(
      args?: Subset<T, Det_pembelianCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Det_pembelianCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Det_pembelian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Det_pembelianAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Det_pembelianAggregateArgs>(args: Subset<T, Det_pembelianAggregateArgs>): Prisma.PrismaPromise<GetDet_pembelianAggregateType<T>>

    /**
     * Group by Det_pembelian.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Det_pembelianGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Det_pembelianGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Det_pembelianGroupByArgs['orderBy'] }
        : { orderBy?: Det_pembelianGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Det_pembelianGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDet_pembelianGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Det_pembelian model
   */
  readonly fields: Det_pembelianFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Det_pembelian.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Det_pembelianClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    pembelian<T extends PembelianArgs<ExtArgs> = {}>(args?: Subset<T, PembelianArgs<ExtArgs>>): Prisma__PembelianClient<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    obat<T extends ObatArgs<ExtArgs> = {}>(args?: Subset<T, ObatArgs<ExtArgs>>): Prisma__ObatClient<$Types.GetResult<ObatPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Det_pembelian model
   */ 
  interface Det_pembelianFieldRefs {
    readonly id: FieldRef<"Det_pembelian", 'String'>
    readonly id_faktur: FieldRef<"Det_pembelian", 'String'>
    readonly id_obat: FieldRef<"Det_pembelian", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Det_pembelian findUnique
   */
  export type Det_pembelianFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
    /**
     * Filter, which Det_pembelian to fetch.
     */
    where: Det_pembelianWhereUniqueInput
  }


  /**
   * Det_pembelian findUniqueOrThrow
   */
  export type Det_pembelianFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
    /**
     * Filter, which Det_pembelian to fetch.
     */
    where: Det_pembelianWhereUniqueInput
  }


  /**
   * Det_pembelian findFirst
   */
  export type Det_pembelianFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
    /**
     * Filter, which Det_pembelian to fetch.
     */
    where?: Det_pembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Det_pembelians to fetch.
     */
    orderBy?: Det_pembelianOrderByWithRelationInput | Det_pembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Det_pembelians.
     */
    cursor?: Det_pembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Det_pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Det_pembelians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Det_pembelians.
     */
    distinct?: Det_pembelianScalarFieldEnum | Det_pembelianScalarFieldEnum[]
  }


  /**
   * Det_pembelian findFirstOrThrow
   */
  export type Det_pembelianFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
    /**
     * Filter, which Det_pembelian to fetch.
     */
    where?: Det_pembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Det_pembelians to fetch.
     */
    orderBy?: Det_pembelianOrderByWithRelationInput | Det_pembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Det_pembelians.
     */
    cursor?: Det_pembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Det_pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Det_pembelians.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Det_pembelians.
     */
    distinct?: Det_pembelianScalarFieldEnum | Det_pembelianScalarFieldEnum[]
  }


  /**
   * Det_pembelian findMany
   */
  export type Det_pembelianFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
    /**
     * Filter, which Det_pembelians to fetch.
     */
    where?: Det_pembelianWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Det_pembelians to fetch.
     */
    orderBy?: Det_pembelianOrderByWithRelationInput | Det_pembelianOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Det_pembelians.
     */
    cursor?: Det_pembelianWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Det_pembelians from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Det_pembelians.
     */
    skip?: number
    distinct?: Det_pembelianScalarFieldEnum | Det_pembelianScalarFieldEnum[]
  }


  /**
   * Det_pembelian create
   */
  export type Det_pembelianCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
    /**
     * The data needed to create a Det_pembelian.
     */
    data: XOR<Det_pembelianCreateInput, Det_pembelianUncheckedCreateInput>
  }


  /**
   * Det_pembelian createMany
   */
  export type Det_pembelianCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Det_pembelians.
     */
    data: Det_pembelianCreateManyInput | Det_pembelianCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Det_pembelian update
   */
  export type Det_pembelianUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
    /**
     * The data needed to update a Det_pembelian.
     */
    data: XOR<Det_pembelianUpdateInput, Det_pembelianUncheckedUpdateInput>
    /**
     * Choose, which Det_pembelian to update.
     */
    where: Det_pembelianWhereUniqueInput
  }


  /**
   * Det_pembelian updateMany
   */
  export type Det_pembelianUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Det_pembelians.
     */
    data: XOR<Det_pembelianUpdateManyMutationInput, Det_pembelianUncheckedUpdateManyInput>
    /**
     * Filter which Det_pembelians to update
     */
    where?: Det_pembelianWhereInput
  }


  /**
   * Det_pembelian upsert
   */
  export type Det_pembelianUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
    /**
     * The filter to search for the Det_pembelian to update in case it exists.
     */
    where: Det_pembelianWhereUniqueInput
    /**
     * In case the Det_pembelian found by the `where` argument doesn't exist, create a new Det_pembelian with this data.
     */
    create: XOR<Det_pembelianCreateInput, Det_pembelianUncheckedCreateInput>
    /**
     * In case the Det_pembelian was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Det_pembelianUpdateInput, Det_pembelianUncheckedUpdateInput>
  }


  /**
   * Det_pembelian delete
   */
  export type Det_pembelianDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
    /**
     * Filter which Det_pembelian to delete.
     */
    where: Det_pembelianWhereUniqueInput
  }


  /**
   * Det_pembelian deleteMany
   */
  export type Det_pembelianDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Det_pembelians to delete
     */
    where?: Det_pembelianWhereInput
  }


  /**
   * Det_pembelian without action
   */
  export type Det_pembelianArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Det_pembelian
     */
    select?: Det_pembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Det_pembelianInclude<ExtArgs> | null
  }



  /**
   * Model Staff_gudang
   */


  export type AggregateStaff_gudang = {
    _count: Staff_gudangCountAggregateOutputType | null
    _min: Staff_gudangMinAggregateOutputType | null
    _max: Staff_gudangMaxAggregateOutputType | null
  }

  export type Staff_gudangMinAggregateOutputType = {
    id: string | null
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }

  export type Staff_gudangMaxAggregateOutputType = {
    id: string | null
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }

  export type Staff_gudangCountAggregateOutputType = {
    id: number
    nama: number
    alamat: number
    no_telp: number
    _all: number
  }


  export type Staff_gudangMinAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
  }

  export type Staff_gudangMaxAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
  }

  export type Staff_gudangCountAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
    _all?: true
  }

  export type Staff_gudangAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff_gudang to aggregate.
     */
    where?: Staff_gudangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff_gudangs to fetch.
     */
    orderBy?: Staff_gudangOrderByWithRelationInput | Staff_gudangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: Staff_gudangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff_gudangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff_gudangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Staff_gudangs
    **/
    _count?: true | Staff_gudangCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Staff_gudangMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Staff_gudangMaxAggregateInputType
  }

  export type GetStaff_gudangAggregateType<T extends Staff_gudangAggregateArgs> = {
        [P in keyof T & keyof AggregateStaff_gudang]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaff_gudang[P]>
      : GetScalarType<T[P], AggregateStaff_gudang[P]>
  }




  export type Staff_gudangGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: Staff_gudangWhereInput
    orderBy?: Staff_gudangOrderByWithAggregationInput | Staff_gudangOrderByWithAggregationInput[]
    by: Staff_gudangScalarFieldEnum[] | Staff_gudangScalarFieldEnum
    having?: Staff_gudangScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Staff_gudangCountAggregateInputType | true
    _min?: Staff_gudangMinAggregateInputType
    _max?: Staff_gudangMaxAggregateInputType
  }


  export type Staff_gudangGroupByOutputType = {
    id: string
    nama: string | null
    alamat: string | null
    no_telp: string | null
    _count: Staff_gudangCountAggregateOutputType | null
    _min: Staff_gudangMinAggregateOutputType | null
    _max: Staff_gudangMaxAggregateOutputType | null
  }

  type GetStaff_gudangGroupByPayload<T extends Staff_gudangGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Staff_gudangGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Staff_gudangGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Staff_gudangGroupByOutputType[P]>
            : GetScalarType<T[P], Staff_gudangGroupByOutputType[P]>
        }
      >
    >


  export type Staff_gudangSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    alamat?: boolean
    no_telp?: boolean
    Obat?: boolean | Staff_gudang$ObatArgs<ExtArgs>
    _count?: boolean | Staff_gudangCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["staff_gudang"]>

  export type Staff_gudangSelectScalar = {
    id?: boolean
    nama?: boolean
    alamat?: boolean
    no_telp?: boolean
  }

  export type Staff_gudangInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Obat?: boolean | Staff_gudang$ObatArgs<ExtArgs>
    _count?: boolean | Staff_gudangCountOutputTypeArgs<ExtArgs>
  }


  type Staff_gudangGetPayload<S extends boolean | null | undefined | Staff_gudangArgs> = $Types.GetResult<Staff_gudangPayload, S>

  type Staff_gudangCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<Staff_gudangFindManyArgs, 'select' | 'include'> & {
      select?: Staff_gudangCountAggregateInputType | true
    }

  export interface Staff_gudangDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Staff_gudang'], meta: { name: 'Staff_gudang' } }
    /**
     * Find zero or one Staff_gudang that matches the filter.
     * @param {Staff_gudangFindUniqueArgs} args - Arguments to find a Staff_gudang
     * @example
     * // Get one Staff_gudang
     * const staff_gudang = await prisma.staff_gudang.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends Staff_gudangFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, Staff_gudangFindUniqueArgs<ExtArgs>>
    ): Prisma__Staff_gudangClient<$Types.GetResult<Staff_gudangPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Staff_gudang that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {Staff_gudangFindUniqueOrThrowArgs} args - Arguments to find a Staff_gudang
     * @example
     * // Get one Staff_gudang
     * const staff_gudang = await prisma.staff_gudang.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends Staff_gudangFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Staff_gudangFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__Staff_gudangClient<$Types.GetResult<Staff_gudangPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Staff_gudang that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Staff_gudangFindFirstArgs} args - Arguments to find a Staff_gudang
     * @example
     * // Get one Staff_gudang
     * const staff_gudang = await prisma.staff_gudang.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends Staff_gudangFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, Staff_gudangFindFirstArgs<ExtArgs>>
    ): Prisma__Staff_gudangClient<$Types.GetResult<Staff_gudangPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Staff_gudang that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Staff_gudangFindFirstOrThrowArgs} args - Arguments to find a Staff_gudang
     * @example
     * // Get one Staff_gudang
     * const staff_gudang = await prisma.staff_gudang.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends Staff_gudangFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, Staff_gudangFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__Staff_gudangClient<$Types.GetResult<Staff_gudangPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Staff_gudangs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Staff_gudangFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Staff_gudangs
     * const staff_gudangs = await prisma.staff_gudang.findMany()
     * 
     * // Get first 10 Staff_gudangs
     * const staff_gudangs = await prisma.staff_gudang.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staff_gudangWithIdOnly = await prisma.staff_gudang.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends Staff_gudangFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Staff_gudangFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<Staff_gudangPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Staff_gudang.
     * @param {Staff_gudangCreateArgs} args - Arguments to create a Staff_gudang.
     * @example
     * // Create one Staff_gudang
     * const Staff_gudang = await prisma.staff_gudang.create({
     *   data: {
     *     // ... data to create a Staff_gudang
     *   }
     * })
     * 
    **/
    create<T extends Staff_gudangCreateArgs<ExtArgs>>(
      args: SelectSubset<T, Staff_gudangCreateArgs<ExtArgs>>
    ): Prisma__Staff_gudangClient<$Types.GetResult<Staff_gudangPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Staff_gudangs.
     *     @param {Staff_gudangCreateManyArgs} args - Arguments to create many Staff_gudangs.
     *     @example
     *     // Create many Staff_gudangs
     *     const staff_gudang = await prisma.staff_gudang.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends Staff_gudangCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Staff_gudangCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Staff_gudang.
     * @param {Staff_gudangDeleteArgs} args - Arguments to delete one Staff_gudang.
     * @example
     * // Delete one Staff_gudang
     * const Staff_gudang = await prisma.staff_gudang.delete({
     *   where: {
     *     // ... filter to delete one Staff_gudang
     *   }
     * })
     * 
    **/
    delete<T extends Staff_gudangDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, Staff_gudangDeleteArgs<ExtArgs>>
    ): Prisma__Staff_gudangClient<$Types.GetResult<Staff_gudangPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Staff_gudang.
     * @param {Staff_gudangUpdateArgs} args - Arguments to update one Staff_gudang.
     * @example
     * // Update one Staff_gudang
     * const staff_gudang = await prisma.staff_gudang.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends Staff_gudangUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, Staff_gudangUpdateArgs<ExtArgs>>
    ): Prisma__Staff_gudangClient<$Types.GetResult<Staff_gudangPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Staff_gudangs.
     * @param {Staff_gudangDeleteManyArgs} args - Arguments to filter Staff_gudangs to delete.
     * @example
     * // Delete a few Staff_gudangs
     * const { count } = await prisma.staff_gudang.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends Staff_gudangDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, Staff_gudangDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Staff_gudangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Staff_gudangUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Staff_gudangs
     * const staff_gudang = await prisma.staff_gudang.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends Staff_gudangUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, Staff_gudangUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Staff_gudang.
     * @param {Staff_gudangUpsertArgs} args - Arguments to update or create a Staff_gudang.
     * @example
     * // Update or create a Staff_gudang
     * const staff_gudang = await prisma.staff_gudang.upsert({
     *   create: {
     *     // ... data to create a Staff_gudang
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Staff_gudang we want to update
     *   }
     * })
    **/
    upsert<T extends Staff_gudangUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, Staff_gudangUpsertArgs<ExtArgs>>
    ): Prisma__Staff_gudangClient<$Types.GetResult<Staff_gudangPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Staff_gudangs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Staff_gudangCountArgs} args - Arguments to filter Staff_gudangs to count.
     * @example
     * // Count the number of Staff_gudangs
     * const count = await prisma.staff_gudang.count({
     *   where: {
     *     // ... the filter for the Staff_gudangs we want to count
     *   }
     * })
    **/
    count<T extends Staff_gudangCountArgs>(
      args?: Subset<T, Staff_gudangCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Staff_gudangCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Staff_gudang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Staff_gudangAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Staff_gudangAggregateArgs>(args: Subset<T, Staff_gudangAggregateArgs>): Prisma.PrismaPromise<GetStaff_gudangAggregateType<T>>

    /**
     * Group by Staff_gudang.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Staff_gudangGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Staff_gudangGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Staff_gudangGroupByArgs['orderBy'] }
        : { orderBy?: Staff_gudangGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Staff_gudangGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaff_gudangGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Staff_gudang model
   */
  readonly fields: Staff_gudangFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Staff_gudang.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__Staff_gudangClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Obat<T extends Staff_gudang$ObatArgs<ExtArgs> = {}>(args?: Subset<T, Staff_gudang$ObatArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ObatPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Staff_gudang model
   */ 
  interface Staff_gudangFieldRefs {
    readonly id: FieldRef<"Staff_gudang", 'String'>
    readonly nama: FieldRef<"Staff_gudang", 'String'>
    readonly alamat: FieldRef<"Staff_gudang", 'String'>
    readonly no_telp: FieldRef<"Staff_gudang", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Staff_gudang findUnique
   */
  export type Staff_gudangFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff_gudang
     */
    select?: Staff_gudangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Staff_gudangInclude<ExtArgs> | null
    /**
     * Filter, which Staff_gudang to fetch.
     */
    where: Staff_gudangWhereUniqueInput
  }


  /**
   * Staff_gudang findUniqueOrThrow
   */
  export type Staff_gudangFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff_gudang
     */
    select?: Staff_gudangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Staff_gudangInclude<ExtArgs> | null
    /**
     * Filter, which Staff_gudang to fetch.
     */
    where: Staff_gudangWhereUniqueInput
  }


  /**
   * Staff_gudang findFirst
   */
  export type Staff_gudangFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff_gudang
     */
    select?: Staff_gudangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Staff_gudangInclude<ExtArgs> | null
    /**
     * Filter, which Staff_gudang to fetch.
     */
    where?: Staff_gudangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff_gudangs to fetch.
     */
    orderBy?: Staff_gudangOrderByWithRelationInput | Staff_gudangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff_gudangs.
     */
    cursor?: Staff_gudangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff_gudangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff_gudangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff_gudangs.
     */
    distinct?: Staff_gudangScalarFieldEnum | Staff_gudangScalarFieldEnum[]
  }


  /**
   * Staff_gudang findFirstOrThrow
   */
  export type Staff_gudangFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff_gudang
     */
    select?: Staff_gudangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Staff_gudangInclude<ExtArgs> | null
    /**
     * Filter, which Staff_gudang to fetch.
     */
    where?: Staff_gudangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff_gudangs to fetch.
     */
    orderBy?: Staff_gudangOrderByWithRelationInput | Staff_gudangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Staff_gudangs.
     */
    cursor?: Staff_gudangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff_gudangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff_gudangs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Staff_gudangs.
     */
    distinct?: Staff_gudangScalarFieldEnum | Staff_gudangScalarFieldEnum[]
  }


  /**
   * Staff_gudang findMany
   */
  export type Staff_gudangFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff_gudang
     */
    select?: Staff_gudangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Staff_gudangInclude<ExtArgs> | null
    /**
     * Filter, which Staff_gudangs to fetch.
     */
    where?: Staff_gudangWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Staff_gudangs to fetch.
     */
    orderBy?: Staff_gudangOrderByWithRelationInput | Staff_gudangOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Staff_gudangs.
     */
    cursor?: Staff_gudangWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Staff_gudangs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Staff_gudangs.
     */
    skip?: number
    distinct?: Staff_gudangScalarFieldEnum | Staff_gudangScalarFieldEnum[]
  }


  /**
   * Staff_gudang create
   */
  export type Staff_gudangCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff_gudang
     */
    select?: Staff_gudangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Staff_gudangInclude<ExtArgs> | null
    /**
     * The data needed to create a Staff_gudang.
     */
    data: XOR<Staff_gudangCreateInput, Staff_gudangUncheckedCreateInput>
  }


  /**
   * Staff_gudang createMany
   */
  export type Staff_gudangCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Staff_gudangs.
     */
    data: Staff_gudangCreateManyInput | Staff_gudangCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Staff_gudang update
   */
  export type Staff_gudangUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff_gudang
     */
    select?: Staff_gudangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Staff_gudangInclude<ExtArgs> | null
    /**
     * The data needed to update a Staff_gudang.
     */
    data: XOR<Staff_gudangUpdateInput, Staff_gudangUncheckedUpdateInput>
    /**
     * Choose, which Staff_gudang to update.
     */
    where: Staff_gudangWhereUniqueInput
  }


  /**
   * Staff_gudang updateMany
   */
  export type Staff_gudangUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Staff_gudangs.
     */
    data: XOR<Staff_gudangUpdateManyMutationInput, Staff_gudangUncheckedUpdateManyInput>
    /**
     * Filter which Staff_gudangs to update
     */
    where?: Staff_gudangWhereInput
  }


  /**
   * Staff_gudang upsert
   */
  export type Staff_gudangUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff_gudang
     */
    select?: Staff_gudangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Staff_gudangInclude<ExtArgs> | null
    /**
     * The filter to search for the Staff_gudang to update in case it exists.
     */
    where: Staff_gudangWhereUniqueInput
    /**
     * In case the Staff_gudang found by the `where` argument doesn't exist, create a new Staff_gudang with this data.
     */
    create: XOR<Staff_gudangCreateInput, Staff_gudangUncheckedCreateInput>
    /**
     * In case the Staff_gudang was found with the provided `where` argument, update it with this data.
     */
    update: XOR<Staff_gudangUpdateInput, Staff_gudangUncheckedUpdateInput>
  }


  /**
   * Staff_gudang delete
   */
  export type Staff_gudangDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff_gudang
     */
    select?: Staff_gudangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Staff_gudangInclude<ExtArgs> | null
    /**
     * Filter which Staff_gudang to delete.
     */
    where: Staff_gudangWhereUniqueInput
  }


  /**
   * Staff_gudang deleteMany
   */
  export type Staff_gudangDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Staff_gudangs to delete
     */
    where?: Staff_gudangWhereInput
  }


  /**
   * Staff_gudang.Obat
   */
  export type Staff_gudang$ObatArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
    where?: ObatWhereInput
    orderBy?: ObatOrderByWithRelationInput | ObatOrderByWithRelationInput[]
    cursor?: ObatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObatScalarFieldEnum | ObatScalarFieldEnum[]
  }


  /**
   * Staff_gudang without action
   */
  export type Staff_gudangArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Staff_gudang
     */
    select?: Staff_gudangSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: Staff_gudangInclude<ExtArgs> | null
  }



  /**
   * Model Supplier
   */


  export type AggregateSupplier = {
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  export type SupplierMinAggregateOutputType = {
    id: string | null
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }

  export type SupplierMaxAggregateOutputType = {
    id: string | null
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }

  export type SupplierCountAggregateOutputType = {
    id: number
    nama: number
    alamat: number
    no_telp: number
    _all: number
  }


  export type SupplierMinAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
  }

  export type SupplierMaxAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
  }

  export type SupplierCountAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
    _all?: true
  }

  export type SupplierAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Supplier to aggregate.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Suppliers
    **/
    _count?: true | SupplierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupplierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupplierMaxAggregateInputType
  }

  export type GetSupplierAggregateType<T extends SupplierAggregateArgs> = {
        [P in keyof T & keyof AggregateSupplier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupplier[P]>
      : GetScalarType<T[P], AggregateSupplier[P]>
  }




  export type SupplierGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: SupplierWhereInput
    orderBy?: SupplierOrderByWithAggregationInput | SupplierOrderByWithAggregationInput[]
    by: SupplierScalarFieldEnum[] | SupplierScalarFieldEnum
    having?: SupplierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupplierCountAggregateInputType | true
    _min?: SupplierMinAggregateInputType
    _max?: SupplierMaxAggregateInputType
  }


  export type SupplierGroupByOutputType = {
    id: string
    nama: string | null
    alamat: string | null
    no_telp: string | null
    _count: SupplierCountAggregateOutputType | null
    _min: SupplierMinAggregateOutputType | null
    _max: SupplierMaxAggregateOutputType | null
  }

  type GetSupplierGroupByPayload<T extends SupplierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupplierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupplierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupplierGroupByOutputType[P]>
            : GetScalarType<T[P], SupplierGroupByOutputType[P]>
        }
      >
    >


  export type SupplierSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    alamat?: boolean
    no_telp?: boolean
    Obat?: boolean | Supplier$ObatArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["supplier"]>

  export type SupplierSelectScalar = {
    id?: boolean
    nama?: boolean
    alamat?: boolean
    no_telp?: boolean
  }

  export type SupplierInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    Obat?: boolean | Supplier$ObatArgs<ExtArgs>
    _count?: boolean | SupplierCountOutputTypeArgs<ExtArgs>
  }


  type SupplierGetPayload<S extends boolean | null | undefined | SupplierArgs> = $Types.GetResult<SupplierPayload, S>

  type SupplierCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<SupplierFindManyArgs, 'select' | 'include'> & {
      select?: SupplierCountAggregateInputType | true
    }

  export interface SupplierDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Supplier'], meta: { name: 'Supplier' } }
    /**
     * Find zero or one Supplier that matches the filter.
     * @param {SupplierFindUniqueArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SupplierFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierFindUniqueArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Types.GetResult<SupplierPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Supplier that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {SupplierFindUniqueOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends SupplierFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Types.GetResult<SupplierPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Supplier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SupplierFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Types.GetResult<SupplierPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Supplier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindFirstOrThrowArgs} args - Arguments to find a Supplier
     * @example
     * // Get one Supplier
     * const supplier = await prisma.supplier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends SupplierFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Types.GetResult<SupplierPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Suppliers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Suppliers
     * const suppliers = await prisma.supplier.findMany()
     * 
     * // Get first 10 Suppliers
     * const suppliers = await prisma.supplier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supplierWithIdOnly = await prisma.supplier.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SupplierFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<SupplierPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Supplier.
     * @param {SupplierCreateArgs} args - Arguments to create a Supplier.
     * @example
     * // Create one Supplier
     * const Supplier = await prisma.supplier.create({
     *   data: {
     *     // ... data to create a Supplier
     *   }
     * })
     * 
    **/
    create<T extends SupplierCreateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierCreateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Types.GetResult<SupplierPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Suppliers.
     *     @param {SupplierCreateManyArgs} args - Arguments to create many Suppliers.
     *     @example
     *     // Create many Suppliers
     *     const supplier = await prisma.supplier.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SupplierCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Supplier.
     * @param {SupplierDeleteArgs} args - Arguments to delete one Supplier.
     * @example
     * // Delete one Supplier
     * const Supplier = await prisma.supplier.delete({
     *   where: {
     *     // ... filter to delete one Supplier
     *   }
     * })
     * 
    **/
    delete<T extends SupplierDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierDeleteArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Types.GetResult<SupplierPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Supplier.
     * @param {SupplierUpdateArgs} args - Arguments to update one Supplier.
     * @example
     * // Update one Supplier
     * const supplier = await prisma.supplier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SupplierUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Types.GetResult<SupplierPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Suppliers.
     * @param {SupplierDeleteManyArgs} args - Arguments to filter Suppliers to delete.
     * @example
     * // Delete a few Suppliers
     * const { count } = await prisma.supplier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SupplierDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, SupplierDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Suppliers
     * const supplier = await prisma.supplier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SupplierUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Supplier.
     * @param {SupplierUpsertArgs} args - Arguments to update or create a Supplier.
     * @example
     * // Update or create a Supplier
     * const supplier = await prisma.supplier.upsert({
     *   create: {
     *     // ... data to create a Supplier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Supplier we want to update
     *   }
     * })
    **/
    upsert<T extends SupplierUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, SupplierUpsertArgs<ExtArgs>>
    ): Prisma__SupplierClient<$Types.GetResult<SupplierPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Suppliers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierCountArgs} args - Arguments to filter Suppliers to count.
     * @example
     * // Count the number of Suppliers
     * const count = await prisma.supplier.count({
     *   where: {
     *     // ... the filter for the Suppliers we want to count
     *   }
     * })
    **/
    count<T extends SupplierCountArgs>(
      args?: Subset<T, SupplierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupplierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupplierAggregateArgs>(args: Subset<T, SupplierAggregateArgs>): Prisma.PrismaPromise<GetSupplierAggregateType<T>>

    /**
     * Group by Supplier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupplierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupplierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupplierGroupByArgs['orderBy'] }
        : { orderBy?: SupplierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupplierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupplierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Supplier model
   */
  readonly fields: SupplierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Supplier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SupplierClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    Obat<T extends Supplier$ObatArgs<ExtArgs> = {}>(args?: Subset<T, Supplier$ObatArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<ObatPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Supplier model
   */ 
  interface SupplierFieldRefs {
    readonly id: FieldRef<"Supplier", 'String'>
    readonly nama: FieldRef<"Supplier", 'String'>
    readonly alamat: FieldRef<"Supplier", 'String'>
    readonly no_telp: FieldRef<"Supplier", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Supplier findUnique
   */
  export type SupplierFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier findUniqueOrThrow
   */
  export type SupplierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier findFirst
   */
  export type SupplierFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier findFirstOrThrow
   */
  export type SupplierFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Supplier to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Suppliers.
     */
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier findMany
   */
  export type SupplierFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter, which Suppliers to fetch.
     */
    where?: SupplierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Suppliers to fetch.
     */
    orderBy?: SupplierOrderByWithRelationInput | SupplierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Suppliers.
     */
    cursor?: SupplierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Suppliers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Suppliers.
     */
    skip?: number
    distinct?: SupplierScalarFieldEnum | SupplierScalarFieldEnum[]
  }


  /**
   * Supplier create
   */
  export type SupplierCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to create a Supplier.
     */
    data: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
  }


  /**
   * Supplier createMany
   */
  export type SupplierCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Suppliers.
     */
    data: SupplierCreateManyInput | SupplierCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Supplier update
   */
  export type SupplierUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The data needed to update a Supplier.
     */
    data: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
    /**
     * Choose, which Supplier to update.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier updateMany
   */
  export type SupplierUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Suppliers.
     */
    data: XOR<SupplierUpdateManyMutationInput, SupplierUncheckedUpdateManyInput>
    /**
     * Filter which Suppliers to update
     */
    where?: SupplierWhereInput
  }


  /**
   * Supplier upsert
   */
  export type SupplierUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * The filter to search for the Supplier to update in case it exists.
     */
    where: SupplierWhereUniqueInput
    /**
     * In case the Supplier found by the `where` argument doesn't exist, create a new Supplier with this data.
     */
    create: XOR<SupplierCreateInput, SupplierUncheckedCreateInput>
    /**
     * In case the Supplier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupplierUpdateInput, SupplierUncheckedUpdateInput>
  }


  /**
   * Supplier delete
   */
  export type SupplierDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
    /**
     * Filter which Supplier to delete.
     */
    where: SupplierWhereUniqueInput
  }


  /**
   * Supplier deleteMany
   */
  export type SupplierDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Suppliers to delete
     */
    where?: SupplierWhereInput
  }


  /**
   * Supplier.Obat
   */
  export type Supplier$ObatArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Obat
     */
    select?: ObatSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ObatInclude<ExtArgs> | null
    where?: ObatWhereInput
    orderBy?: ObatOrderByWithRelationInput | ObatOrderByWithRelationInput[]
    cursor?: ObatWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ObatScalarFieldEnum | ObatScalarFieldEnum[]
  }


  /**
   * Supplier without action
   */
  export type SupplierArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Supplier
     */
    select?: SupplierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: SupplierInclude<ExtArgs> | null
  }



  /**
   * Model Apoteker
   */


  export type AggregateApoteker = {
    _count: ApotekerCountAggregateOutputType | null
    _min: ApotekerMinAggregateOutputType | null
    _max: ApotekerMaxAggregateOutputType | null
  }

  export type ApotekerMinAggregateOutputType = {
    id: string | null
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }

  export type ApotekerMaxAggregateOutputType = {
    id: string | null
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }

  export type ApotekerCountAggregateOutputType = {
    id: number
    nama: number
    alamat: number
    no_telp: number
    _all: number
  }


  export type ApotekerMinAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
  }

  export type ApotekerMaxAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
  }

  export type ApotekerCountAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
    _all?: true
  }

  export type ApotekerAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Apoteker to aggregate.
     */
    where?: ApotekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apotekers to fetch.
     */
    orderBy?: ApotekerOrderByWithRelationInput | ApotekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ApotekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apotekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apotekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Apotekers
    **/
    _count?: true | ApotekerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ApotekerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ApotekerMaxAggregateInputType
  }

  export type GetApotekerAggregateType<T extends ApotekerAggregateArgs> = {
        [P in keyof T & keyof AggregateApoteker]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApoteker[P]>
      : GetScalarType<T[P], AggregateApoteker[P]>
  }




  export type ApotekerGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: ApotekerWhereInput
    orderBy?: ApotekerOrderByWithAggregationInput | ApotekerOrderByWithAggregationInput[]
    by: ApotekerScalarFieldEnum[] | ApotekerScalarFieldEnum
    having?: ApotekerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ApotekerCountAggregateInputType | true
    _min?: ApotekerMinAggregateInputType
    _max?: ApotekerMaxAggregateInputType
  }


  export type ApotekerGroupByOutputType = {
    id: string
    nama: string | null
    alamat: string | null
    no_telp: string | null
    _count: ApotekerCountAggregateOutputType | null
    _min: ApotekerMinAggregateOutputType | null
    _max: ApotekerMaxAggregateOutputType | null
  }

  type GetApotekerGroupByPayload<T extends ApotekerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ApotekerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ApotekerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ApotekerGroupByOutputType[P]>
            : GetScalarType<T[P], ApotekerGroupByOutputType[P]>
        }
      >
    >


  export type ApotekerSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    alamat?: boolean
    no_telp?: boolean
    laporan?: boolean | Apoteker$laporanArgs<ExtArgs>
    pembelian?: boolean | Apoteker$pembelianArgs<ExtArgs>
    _count?: boolean | ApotekerCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["apoteker"]>

  export type ApotekerSelectScalar = {
    id?: boolean
    nama?: boolean
    alamat?: boolean
    no_telp?: boolean
  }

  export type ApotekerInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    laporan?: boolean | Apoteker$laporanArgs<ExtArgs>
    pembelian?: boolean | Apoteker$pembelianArgs<ExtArgs>
    _count?: boolean | ApotekerCountOutputTypeArgs<ExtArgs>
  }


  type ApotekerGetPayload<S extends boolean | null | undefined | ApotekerArgs> = $Types.GetResult<ApotekerPayload, S>

  type ApotekerCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<ApotekerFindManyArgs, 'select' | 'include'> & {
      select?: ApotekerCountAggregateInputType | true
    }

  export interface ApotekerDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Apoteker'], meta: { name: 'Apoteker' } }
    /**
     * Find zero or one Apoteker that matches the filter.
     * @param {ApotekerFindUniqueArgs} args - Arguments to find a Apoteker
     * @example
     * // Get one Apoteker
     * const apoteker = await prisma.apoteker.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ApotekerFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ApotekerFindUniqueArgs<ExtArgs>>
    ): Prisma__ApotekerClient<$Types.GetResult<ApotekerPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Apoteker that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {ApotekerFindUniqueOrThrowArgs} args - Arguments to find a Apoteker
     * @example
     * // Get one Apoteker
     * const apoteker = await prisma.apoteker.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ApotekerFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApotekerFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ApotekerClient<$Types.GetResult<ApotekerPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Apoteker that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApotekerFindFirstArgs} args - Arguments to find a Apoteker
     * @example
     * // Get one Apoteker
     * const apoteker = await prisma.apoteker.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ApotekerFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ApotekerFindFirstArgs<ExtArgs>>
    ): Prisma__ApotekerClient<$Types.GetResult<ApotekerPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Apoteker that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApotekerFindFirstOrThrowArgs} args - Arguments to find a Apoteker
     * @example
     * // Get one Apoteker
     * const apoteker = await prisma.apoteker.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ApotekerFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ApotekerFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ApotekerClient<$Types.GetResult<ApotekerPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Apotekers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApotekerFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apotekers
     * const apotekers = await prisma.apoteker.findMany()
     * 
     * // Get first 10 Apotekers
     * const apotekers = await prisma.apoteker.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const apotekerWithIdOnly = await prisma.apoteker.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ApotekerFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApotekerFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<ApotekerPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Apoteker.
     * @param {ApotekerCreateArgs} args - Arguments to create a Apoteker.
     * @example
     * // Create one Apoteker
     * const Apoteker = await prisma.apoteker.create({
     *   data: {
     *     // ... data to create a Apoteker
     *   }
     * })
     * 
    **/
    create<T extends ApotekerCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ApotekerCreateArgs<ExtArgs>>
    ): Prisma__ApotekerClient<$Types.GetResult<ApotekerPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Apotekers.
     *     @param {ApotekerCreateManyArgs} args - Arguments to create many Apotekers.
     *     @example
     *     // Create many Apotekers
     *     const apoteker = await prisma.apoteker.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ApotekerCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApotekerCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Apoteker.
     * @param {ApotekerDeleteArgs} args - Arguments to delete one Apoteker.
     * @example
     * // Delete one Apoteker
     * const Apoteker = await prisma.apoteker.delete({
     *   where: {
     *     // ... filter to delete one Apoteker
     *   }
     * })
     * 
    **/
    delete<T extends ApotekerDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ApotekerDeleteArgs<ExtArgs>>
    ): Prisma__ApotekerClient<$Types.GetResult<ApotekerPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Apoteker.
     * @param {ApotekerUpdateArgs} args - Arguments to update one Apoteker.
     * @example
     * // Update one Apoteker
     * const apoteker = await prisma.apoteker.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ApotekerUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ApotekerUpdateArgs<ExtArgs>>
    ): Prisma__ApotekerClient<$Types.GetResult<ApotekerPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Apotekers.
     * @param {ApotekerDeleteManyArgs} args - Arguments to filter Apotekers to delete.
     * @example
     * // Delete a few Apotekers
     * const { count } = await prisma.apoteker.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ApotekerDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ApotekerDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apotekers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApotekerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apotekers
     * const apoteker = await prisma.apoteker.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ApotekerUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ApotekerUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Apoteker.
     * @param {ApotekerUpsertArgs} args - Arguments to update or create a Apoteker.
     * @example
     * // Update or create a Apoteker
     * const apoteker = await prisma.apoteker.upsert({
     *   create: {
     *     // ... data to create a Apoteker
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Apoteker we want to update
     *   }
     * })
    **/
    upsert<T extends ApotekerUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ApotekerUpsertArgs<ExtArgs>>
    ): Prisma__ApotekerClient<$Types.GetResult<ApotekerPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Apotekers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApotekerCountArgs} args - Arguments to filter Apotekers to count.
     * @example
     * // Count the number of Apotekers
     * const count = await prisma.apoteker.count({
     *   where: {
     *     // ... the filter for the Apotekers we want to count
     *   }
     * })
    **/
    count<T extends ApotekerCountArgs>(
      args?: Subset<T, ApotekerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ApotekerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Apoteker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApotekerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ApotekerAggregateArgs>(args: Subset<T, ApotekerAggregateArgs>): Prisma.PrismaPromise<GetApotekerAggregateType<T>>

    /**
     * Group by Apoteker.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ApotekerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ApotekerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ApotekerGroupByArgs['orderBy'] }
        : { orderBy?: ApotekerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ApotekerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetApotekerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Apoteker model
   */
  readonly fields: ApotekerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Apoteker.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ApotekerClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    laporan<T extends Apoteker$laporanArgs<ExtArgs> = {}>(args?: Subset<T, Apoteker$laporanArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LaporanPayload<ExtArgs>, T, 'findMany'>| Null>;

    pembelian<T extends Apoteker$pembelianArgs<ExtArgs> = {}>(args?: Subset<T, Apoteker$pembelianArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Apoteker model
   */ 
  interface ApotekerFieldRefs {
    readonly id: FieldRef<"Apoteker", 'String'>
    readonly nama: FieldRef<"Apoteker", 'String'>
    readonly alamat: FieldRef<"Apoteker", 'String'>
    readonly no_telp: FieldRef<"Apoteker", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Apoteker findUnique
   */
  export type ApotekerFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apoteker
     */
    select?: ApotekerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApotekerInclude<ExtArgs> | null
    /**
     * Filter, which Apoteker to fetch.
     */
    where: ApotekerWhereUniqueInput
  }


  /**
   * Apoteker findUniqueOrThrow
   */
  export type ApotekerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apoteker
     */
    select?: ApotekerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApotekerInclude<ExtArgs> | null
    /**
     * Filter, which Apoteker to fetch.
     */
    where: ApotekerWhereUniqueInput
  }


  /**
   * Apoteker findFirst
   */
  export type ApotekerFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apoteker
     */
    select?: ApotekerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApotekerInclude<ExtArgs> | null
    /**
     * Filter, which Apoteker to fetch.
     */
    where?: ApotekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apotekers to fetch.
     */
    orderBy?: ApotekerOrderByWithRelationInput | ApotekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apotekers.
     */
    cursor?: ApotekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apotekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apotekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apotekers.
     */
    distinct?: ApotekerScalarFieldEnum | ApotekerScalarFieldEnum[]
  }


  /**
   * Apoteker findFirstOrThrow
   */
  export type ApotekerFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apoteker
     */
    select?: ApotekerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApotekerInclude<ExtArgs> | null
    /**
     * Filter, which Apoteker to fetch.
     */
    where?: ApotekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apotekers to fetch.
     */
    orderBy?: ApotekerOrderByWithRelationInput | ApotekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apotekers.
     */
    cursor?: ApotekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apotekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apotekers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apotekers.
     */
    distinct?: ApotekerScalarFieldEnum | ApotekerScalarFieldEnum[]
  }


  /**
   * Apoteker findMany
   */
  export type ApotekerFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apoteker
     */
    select?: ApotekerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApotekerInclude<ExtArgs> | null
    /**
     * Filter, which Apotekers to fetch.
     */
    where?: ApotekerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apotekers to fetch.
     */
    orderBy?: ApotekerOrderByWithRelationInput | ApotekerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Apotekers.
     */
    cursor?: ApotekerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apotekers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apotekers.
     */
    skip?: number
    distinct?: ApotekerScalarFieldEnum | ApotekerScalarFieldEnum[]
  }


  /**
   * Apoteker create
   */
  export type ApotekerCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apoteker
     */
    select?: ApotekerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApotekerInclude<ExtArgs> | null
    /**
     * The data needed to create a Apoteker.
     */
    data: XOR<ApotekerCreateInput, ApotekerUncheckedCreateInput>
  }


  /**
   * Apoteker createMany
   */
  export type ApotekerCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Apotekers.
     */
    data: ApotekerCreateManyInput | ApotekerCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Apoteker update
   */
  export type ApotekerUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apoteker
     */
    select?: ApotekerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApotekerInclude<ExtArgs> | null
    /**
     * The data needed to update a Apoteker.
     */
    data: XOR<ApotekerUpdateInput, ApotekerUncheckedUpdateInput>
    /**
     * Choose, which Apoteker to update.
     */
    where: ApotekerWhereUniqueInput
  }


  /**
   * Apoteker updateMany
   */
  export type ApotekerUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Apotekers.
     */
    data: XOR<ApotekerUpdateManyMutationInput, ApotekerUncheckedUpdateManyInput>
    /**
     * Filter which Apotekers to update
     */
    where?: ApotekerWhereInput
  }


  /**
   * Apoteker upsert
   */
  export type ApotekerUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apoteker
     */
    select?: ApotekerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApotekerInclude<ExtArgs> | null
    /**
     * The filter to search for the Apoteker to update in case it exists.
     */
    where: ApotekerWhereUniqueInput
    /**
     * In case the Apoteker found by the `where` argument doesn't exist, create a new Apoteker with this data.
     */
    create: XOR<ApotekerCreateInput, ApotekerUncheckedCreateInput>
    /**
     * In case the Apoteker was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ApotekerUpdateInput, ApotekerUncheckedUpdateInput>
  }


  /**
   * Apoteker delete
   */
  export type ApotekerDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apoteker
     */
    select?: ApotekerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApotekerInclude<ExtArgs> | null
    /**
     * Filter which Apoteker to delete.
     */
    where: ApotekerWhereUniqueInput
  }


  /**
   * Apoteker deleteMany
   */
  export type ApotekerDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Apotekers to delete
     */
    where?: ApotekerWhereInput
  }


  /**
   * Apoteker.laporan
   */
  export type Apoteker$laporanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
    where?: LaporanWhereInput
    orderBy?: LaporanOrderByWithRelationInput | LaporanOrderByWithRelationInput[]
    cursor?: LaporanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaporanScalarFieldEnum | LaporanScalarFieldEnum[]
  }


  /**
   * Apoteker.pembelian
   */
  export type Apoteker$pembelianArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
    where?: PembelianWhereInput
    orderBy?: PembelianOrderByWithRelationInput | PembelianOrderByWithRelationInput[]
    cursor?: PembelianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PembelianScalarFieldEnum | PembelianScalarFieldEnum[]
  }


  /**
   * Apoteker without action
   */
  export type ApotekerArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Apoteker
     */
    select?: ApotekerSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: ApotekerInclude<ExtArgs> | null
  }



  /**
   * Model Pelanggan
   */


  export type AggregatePelanggan = {
    _count: PelangganCountAggregateOutputType | null
    _min: PelangganMinAggregateOutputType | null
    _max: PelangganMaxAggregateOutputType | null
  }

  export type PelangganMinAggregateOutputType = {
    id: string | null
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }

  export type PelangganMaxAggregateOutputType = {
    id: string | null
    nama: string | null
    alamat: string | null
    no_telp: string | null
  }

  export type PelangganCountAggregateOutputType = {
    id: number
    nama: number
    alamat: number
    no_telp: number
    _all: number
  }


  export type PelangganMinAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
  }

  export type PelangganMaxAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
  }

  export type PelangganCountAggregateInputType = {
    id?: true
    nama?: true
    alamat?: true
    no_telp?: true
    _all?: true
  }

  export type PelangganAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pelanggan to aggregate.
     */
    where?: PelangganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggans to fetch.
     */
    orderBy?: PelangganOrderByWithRelationInput | PelangganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PelangganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pelanggans
    **/
    _count?: true | PelangganCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PelangganMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PelangganMaxAggregateInputType
  }

  export type GetPelangganAggregateType<T extends PelangganAggregateArgs> = {
        [P in keyof T & keyof AggregatePelanggan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePelanggan[P]>
      : GetScalarType<T[P], AggregatePelanggan[P]>
  }




  export type PelangganGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PelangganWhereInput
    orderBy?: PelangganOrderByWithAggregationInput | PelangganOrderByWithAggregationInput[]
    by: PelangganScalarFieldEnum[] | PelangganScalarFieldEnum
    having?: PelangganScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PelangganCountAggregateInputType | true
    _min?: PelangganMinAggregateInputType
    _max?: PelangganMaxAggregateInputType
  }


  export type PelangganGroupByOutputType = {
    id: string
    nama: string | null
    alamat: string | null
    no_telp: string | null
    _count: PelangganCountAggregateOutputType | null
    _min: PelangganMinAggregateOutputType | null
    _max: PelangganMaxAggregateOutputType | null
  }

  type GetPelangganGroupByPayload<T extends PelangganGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PelangganGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PelangganGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PelangganGroupByOutputType[P]>
            : GetScalarType<T[P], PelangganGroupByOutputType[P]>
        }
      >
    >


  export type PelangganSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nama?: boolean
    alamat?: boolean
    no_telp?: boolean
    pembelian?: boolean | Pelanggan$pembelianArgs<ExtArgs>
    _count?: boolean | PelangganCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["pelanggan"]>

  export type PelangganSelectScalar = {
    id?: boolean
    nama?: boolean
    alamat?: boolean
    no_telp?: boolean
  }

  export type PelangganInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    pembelian?: boolean | Pelanggan$pembelianArgs<ExtArgs>
    _count?: boolean | PelangganCountOutputTypeArgs<ExtArgs>
  }


  type PelangganGetPayload<S extends boolean | null | undefined | PelangganArgs> = $Types.GetResult<PelangganPayload, S>

  type PelangganCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PelangganFindManyArgs, 'select' | 'include'> & {
      select?: PelangganCountAggregateInputType | true
    }

  export interface PelangganDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pelanggan'], meta: { name: 'Pelanggan' } }
    /**
     * Find zero or one Pelanggan that matches the filter.
     * @param {PelangganFindUniqueArgs} args - Arguments to find a Pelanggan
     * @example
     * // Get one Pelanggan
     * const pelanggan = await prisma.pelanggan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PelangganFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PelangganFindUniqueArgs<ExtArgs>>
    ): Prisma__PelangganClient<$Types.GetResult<PelangganPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pelanggan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PelangganFindUniqueOrThrowArgs} args - Arguments to find a Pelanggan
     * @example
     * // Get one Pelanggan
     * const pelanggan = await prisma.pelanggan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PelangganFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PelangganFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PelangganClient<$Types.GetResult<PelangganPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pelanggan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelangganFindFirstArgs} args - Arguments to find a Pelanggan
     * @example
     * // Get one Pelanggan
     * const pelanggan = await prisma.pelanggan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PelangganFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PelangganFindFirstArgs<ExtArgs>>
    ): Prisma__PelangganClient<$Types.GetResult<PelangganPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pelanggan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelangganFindFirstOrThrowArgs} args - Arguments to find a Pelanggan
     * @example
     * // Get one Pelanggan
     * const pelanggan = await prisma.pelanggan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PelangganFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PelangganFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PelangganClient<$Types.GetResult<PelangganPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pelanggans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelangganFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pelanggans
     * const pelanggans = await prisma.pelanggan.findMany()
     * 
     * // Get first 10 Pelanggans
     * const pelanggans = await prisma.pelanggan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pelangganWithIdOnly = await prisma.pelanggan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PelangganFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PelangganFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PelangganPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pelanggan.
     * @param {PelangganCreateArgs} args - Arguments to create a Pelanggan.
     * @example
     * // Create one Pelanggan
     * const Pelanggan = await prisma.pelanggan.create({
     *   data: {
     *     // ... data to create a Pelanggan
     *   }
     * })
     * 
    **/
    create<T extends PelangganCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PelangganCreateArgs<ExtArgs>>
    ): Prisma__PelangganClient<$Types.GetResult<PelangganPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pelanggans.
     *     @param {PelangganCreateManyArgs} args - Arguments to create many Pelanggans.
     *     @example
     *     // Create many Pelanggans
     *     const pelanggan = await prisma.pelanggan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PelangganCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PelangganCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pelanggan.
     * @param {PelangganDeleteArgs} args - Arguments to delete one Pelanggan.
     * @example
     * // Delete one Pelanggan
     * const Pelanggan = await prisma.pelanggan.delete({
     *   where: {
     *     // ... filter to delete one Pelanggan
     *   }
     * })
     * 
    **/
    delete<T extends PelangganDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PelangganDeleteArgs<ExtArgs>>
    ): Prisma__PelangganClient<$Types.GetResult<PelangganPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pelanggan.
     * @param {PelangganUpdateArgs} args - Arguments to update one Pelanggan.
     * @example
     * // Update one Pelanggan
     * const pelanggan = await prisma.pelanggan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PelangganUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PelangganUpdateArgs<ExtArgs>>
    ): Prisma__PelangganClient<$Types.GetResult<PelangganPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pelanggans.
     * @param {PelangganDeleteManyArgs} args - Arguments to filter Pelanggans to delete.
     * @example
     * // Delete a few Pelanggans
     * const { count } = await prisma.pelanggan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PelangganDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PelangganDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pelanggans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelangganUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pelanggans
     * const pelanggan = await prisma.pelanggan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PelangganUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PelangganUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pelanggan.
     * @param {PelangganUpsertArgs} args - Arguments to update or create a Pelanggan.
     * @example
     * // Update or create a Pelanggan
     * const pelanggan = await prisma.pelanggan.upsert({
     *   create: {
     *     // ... data to create a Pelanggan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pelanggan we want to update
     *   }
     * })
    **/
    upsert<T extends PelangganUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PelangganUpsertArgs<ExtArgs>>
    ): Prisma__PelangganClient<$Types.GetResult<PelangganPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pelanggans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelangganCountArgs} args - Arguments to filter Pelanggans to count.
     * @example
     * // Count the number of Pelanggans
     * const count = await prisma.pelanggan.count({
     *   where: {
     *     // ... the filter for the Pelanggans we want to count
     *   }
     * })
    **/
    count<T extends PelangganCountArgs>(
      args?: Subset<T, PelangganCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PelangganCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pelanggan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelangganAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PelangganAggregateArgs>(args: Subset<T, PelangganAggregateArgs>): Prisma.PrismaPromise<GetPelangganAggregateType<T>>

    /**
     * Group by Pelanggan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PelangganGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PelangganGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PelangganGroupByArgs['orderBy'] }
        : { orderBy?: PelangganGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PelangganGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPelangganGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pelanggan model
   */
  readonly fields: PelangganFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pelanggan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PelangganClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    pembelian<T extends Pelanggan$pembelianArgs<ExtArgs> = {}>(args?: Subset<T, Pelanggan$pembelianArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<PembelianPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Pelanggan model
   */ 
  interface PelangganFieldRefs {
    readonly id: FieldRef<"Pelanggan", 'String'>
    readonly nama: FieldRef<"Pelanggan", 'String'>
    readonly alamat: FieldRef<"Pelanggan", 'String'>
    readonly no_telp: FieldRef<"Pelanggan", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Pelanggan findUnique
   */
  export type PelangganFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggan
     */
    select?: PelangganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PelangganInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggan to fetch.
     */
    where: PelangganWhereUniqueInput
  }


  /**
   * Pelanggan findUniqueOrThrow
   */
  export type PelangganFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggan
     */
    select?: PelangganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PelangganInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggan to fetch.
     */
    where: PelangganWhereUniqueInput
  }


  /**
   * Pelanggan findFirst
   */
  export type PelangganFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggan
     */
    select?: PelangganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PelangganInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggan to fetch.
     */
    where?: PelangganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggans to fetch.
     */
    orderBy?: PelangganOrderByWithRelationInput | PelangganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pelanggans.
     */
    cursor?: PelangganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pelanggans.
     */
    distinct?: PelangganScalarFieldEnum | PelangganScalarFieldEnum[]
  }


  /**
   * Pelanggan findFirstOrThrow
   */
  export type PelangganFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggan
     */
    select?: PelangganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PelangganInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggan to fetch.
     */
    where?: PelangganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggans to fetch.
     */
    orderBy?: PelangganOrderByWithRelationInput | PelangganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pelanggans.
     */
    cursor?: PelangganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pelanggans.
     */
    distinct?: PelangganScalarFieldEnum | PelangganScalarFieldEnum[]
  }


  /**
   * Pelanggan findMany
   */
  export type PelangganFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggan
     */
    select?: PelangganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PelangganInclude<ExtArgs> | null
    /**
     * Filter, which Pelanggans to fetch.
     */
    where?: PelangganWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pelanggans to fetch.
     */
    orderBy?: PelangganOrderByWithRelationInput | PelangganOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pelanggans.
     */
    cursor?: PelangganWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pelanggans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pelanggans.
     */
    skip?: number
    distinct?: PelangganScalarFieldEnum | PelangganScalarFieldEnum[]
  }


  /**
   * Pelanggan create
   */
  export type PelangganCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggan
     */
    select?: PelangganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PelangganInclude<ExtArgs> | null
    /**
     * The data needed to create a Pelanggan.
     */
    data: XOR<PelangganCreateInput, PelangganUncheckedCreateInput>
  }


  /**
   * Pelanggan createMany
   */
  export type PelangganCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pelanggans.
     */
    data: PelangganCreateManyInput | PelangganCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Pelanggan update
   */
  export type PelangganUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggan
     */
    select?: PelangganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PelangganInclude<ExtArgs> | null
    /**
     * The data needed to update a Pelanggan.
     */
    data: XOR<PelangganUpdateInput, PelangganUncheckedUpdateInput>
    /**
     * Choose, which Pelanggan to update.
     */
    where: PelangganWhereUniqueInput
  }


  /**
   * Pelanggan updateMany
   */
  export type PelangganUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pelanggans.
     */
    data: XOR<PelangganUpdateManyMutationInput, PelangganUncheckedUpdateManyInput>
    /**
     * Filter which Pelanggans to update
     */
    where?: PelangganWhereInput
  }


  /**
   * Pelanggan upsert
   */
  export type PelangganUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggan
     */
    select?: PelangganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PelangganInclude<ExtArgs> | null
    /**
     * The filter to search for the Pelanggan to update in case it exists.
     */
    where: PelangganWhereUniqueInput
    /**
     * In case the Pelanggan found by the `where` argument doesn't exist, create a new Pelanggan with this data.
     */
    create: XOR<PelangganCreateInput, PelangganUncheckedCreateInput>
    /**
     * In case the Pelanggan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PelangganUpdateInput, PelangganUncheckedUpdateInput>
  }


  /**
   * Pelanggan delete
   */
  export type PelangganDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggan
     */
    select?: PelangganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PelangganInclude<ExtArgs> | null
    /**
     * Filter which Pelanggan to delete.
     */
    where: PelangganWhereUniqueInput
  }


  /**
   * Pelanggan deleteMany
   */
  export type PelangganDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pelanggans to delete
     */
    where?: PelangganWhereInput
  }


  /**
   * Pelanggan.pembelian
   */
  export type Pelanggan$pembelianArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pembelian
     */
    select?: PembelianSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PembelianInclude<ExtArgs> | null
    where?: PembelianWhereInput
    orderBy?: PembelianOrderByWithRelationInput | PembelianOrderByWithRelationInput[]
    cursor?: PembelianWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PembelianScalarFieldEnum | PembelianScalarFieldEnum[]
  }


  /**
   * Pelanggan without action
   */
  export type PelangganArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pelanggan
     */
    select?: PelangganSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PelangganInclude<ExtArgs> | null
  }



  /**
   * Model Laporan
   */


  export type AggregateLaporan = {
    _count: LaporanCountAggregateOutputType | null
    _avg: LaporanAvgAggregateOutputType | null
    _sum: LaporanSumAggregateOutputType | null
    _min: LaporanMinAggregateOutputType | null
    _max: LaporanMaxAggregateOutputType | null
  }

  export type LaporanAvgAggregateOutputType = {
    id_pemilik: number | null
  }

  export type LaporanSumAggregateOutputType = {
    id_pemilik: number | null
  }

  export type LaporanMinAggregateOutputType = {
    id: string | null
    isi_laporan: string | null
    tanggal_laporan: string | null
    id_apoteker: string | null
    id_pemilik: number | null
  }

  export type LaporanMaxAggregateOutputType = {
    id: string | null
    isi_laporan: string | null
    tanggal_laporan: string | null
    id_apoteker: string | null
    id_pemilik: number | null
  }

  export type LaporanCountAggregateOutputType = {
    id: number
    isi_laporan: number
    tanggal_laporan: number
    id_apoteker: number
    id_pemilik: number
    _all: number
  }


  export type LaporanAvgAggregateInputType = {
    id_pemilik?: true
  }

  export type LaporanSumAggregateInputType = {
    id_pemilik?: true
  }

  export type LaporanMinAggregateInputType = {
    id?: true
    isi_laporan?: true
    tanggal_laporan?: true
    id_apoteker?: true
    id_pemilik?: true
  }

  export type LaporanMaxAggregateInputType = {
    id?: true
    isi_laporan?: true
    tanggal_laporan?: true
    id_apoteker?: true
    id_pemilik?: true
  }

  export type LaporanCountAggregateInputType = {
    id?: true
    isi_laporan?: true
    tanggal_laporan?: true
    id_apoteker?: true
    id_pemilik?: true
    _all?: true
  }

  export type LaporanAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Laporan to aggregate.
     */
    where?: LaporanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Laporans to fetch.
     */
    orderBy?: LaporanOrderByWithRelationInput | LaporanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LaporanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Laporans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Laporans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Laporans
    **/
    _count?: true | LaporanCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LaporanAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LaporanSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LaporanMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LaporanMaxAggregateInputType
  }

  export type GetLaporanAggregateType<T extends LaporanAggregateArgs> = {
        [P in keyof T & keyof AggregateLaporan]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLaporan[P]>
      : GetScalarType<T[P], AggregateLaporan[P]>
  }




  export type LaporanGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: LaporanWhereInput
    orderBy?: LaporanOrderByWithAggregationInput | LaporanOrderByWithAggregationInput[]
    by: LaporanScalarFieldEnum[] | LaporanScalarFieldEnum
    having?: LaporanScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LaporanCountAggregateInputType | true
    _avg?: LaporanAvgAggregateInputType
    _sum?: LaporanSumAggregateInputType
    _min?: LaporanMinAggregateInputType
    _max?: LaporanMaxAggregateInputType
  }


  export type LaporanGroupByOutputType = {
    id: string
    isi_laporan: string
    tanggal_laporan: string
    id_apoteker: string
    id_pemilik: number
    _count: LaporanCountAggregateOutputType | null
    _avg: LaporanAvgAggregateOutputType | null
    _sum: LaporanSumAggregateOutputType | null
    _min: LaporanMinAggregateOutputType | null
    _max: LaporanMaxAggregateOutputType | null
  }

  type GetLaporanGroupByPayload<T extends LaporanGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LaporanGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LaporanGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LaporanGroupByOutputType[P]>
            : GetScalarType<T[P], LaporanGroupByOutputType[P]>
        }
      >
    >


  export type LaporanSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isi_laporan?: boolean
    tanggal_laporan?: boolean
    id_apoteker?: boolean
    id_pemilik?: boolean
    apoteker?: boolean | ApotekerArgs<ExtArgs>
    pemilik?: boolean | PemilikArgs<ExtArgs>
  }, ExtArgs["result"]["laporan"]>

  export type LaporanSelectScalar = {
    id?: boolean
    isi_laporan?: boolean
    tanggal_laporan?: boolean
    id_apoteker?: boolean
    id_pemilik?: boolean
  }

  export type LaporanInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    apoteker?: boolean | ApotekerArgs<ExtArgs>
    pemilik?: boolean | PemilikArgs<ExtArgs>
  }


  type LaporanGetPayload<S extends boolean | null | undefined | LaporanArgs> = $Types.GetResult<LaporanPayload, S>

  type LaporanCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<LaporanFindManyArgs, 'select' | 'include'> & {
      select?: LaporanCountAggregateInputType | true
    }

  export interface LaporanDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Laporan'], meta: { name: 'Laporan' } }
    /**
     * Find zero or one Laporan that matches the filter.
     * @param {LaporanFindUniqueArgs} args - Arguments to find a Laporan
     * @example
     * // Get one Laporan
     * const laporan = await prisma.laporan.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LaporanFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, LaporanFindUniqueArgs<ExtArgs>>
    ): Prisma__LaporanClient<$Types.GetResult<LaporanPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Laporan that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {LaporanFindUniqueOrThrowArgs} args - Arguments to find a Laporan
     * @example
     * // Get one Laporan
     * const laporan = await prisma.laporan.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends LaporanFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LaporanFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__LaporanClient<$Types.GetResult<LaporanPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Laporan that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaporanFindFirstArgs} args - Arguments to find a Laporan
     * @example
     * // Get one Laporan
     * const laporan = await prisma.laporan.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LaporanFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, LaporanFindFirstArgs<ExtArgs>>
    ): Prisma__LaporanClient<$Types.GetResult<LaporanPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Laporan that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaporanFindFirstOrThrowArgs} args - Arguments to find a Laporan
     * @example
     * // Get one Laporan
     * const laporan = await prisma.laporan.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends LaporanFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, LaporanFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__LaporanClient<$Types.GetResult<LaporanPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Laporans that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaporanFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Laporans
     * const laporans = await prisma.laporan.findMany()
     * 
     * // Get first 10 Laporans
     * const laporans = await prisma.laporan.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const laporanWithIdOnly = await prisma.laporan.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LaporanFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LaporanFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<LaporanPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Laporan.
     * @param {LaporanCreateArgs} args - Arguments to create a Laporan.
     * @example
     * // Create one Laporan
     * const Laporan = await prisma.laporan.create({
     *   data: {
     *     // ... data to create a Laporan
     *   }
     * })
     * 
    **/
    create<T extends LaporanCreateArgs<ExtArgs>>(
      args: SelectSubset<T, LaporanCreateArgs<ExtArgs>>
    ): Prisma__LaporanClient<$Types.GetResult<LaporanPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Laporans.
     *     @param {LaporanCreateManyArgs} args - Arguments to create many Laporans.
     *     @example
     *     // Create many Laporans
     *     const laporan = await prisma.laporan.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LaporanCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LaporanCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Laporan.
     * @param {LaporanDeleteArgs} args - Arguments to delete one Laporan.
     * @example
     * // Delete one Laporan
     * const Laporan = await prisma.laporan.delete({
     *   where: {
     *     // ... filter to delete one Laporan
     *   }
     * })
     * 
    **/
    delete<T extends LaporanDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, LaporanDeleteArgs<ExtArgs>>
    ): Prisma__LaporanClient<$Types.GetResult<LaporanPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Laporan.
     * @param {LaporanUpdateArgs} args - Arguments to update one Laporan.
     * @example
     * // Update one Laporan
     * const laporan = await prisma.laporan.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LaporanUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, LaporanUpdateArgs<ExtArgs>>
    ): Prisma__LaporanClient<$Types.GetResult<LaporanPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Laporans.
     * @param {LaporanDeleteManyArgs} args - Arguments to filter Laporans to delete.
     * @example
     * // Delete a few Laporans
     * const { count } = await prisma.laporan.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LaporanDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, LaporanDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Laporans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaporanUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Laporans
     * const laporan = await prisma.laporan.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LaporanUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, LaporanUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Laporan.
     * @param {LaporanUpsertArgs} args - Arguments to update or create a Laporan.
     * @example
     * // Update or create a Laporan
     * const laporan = await prisma.laporan.upsert({
     *   create: {
     *     // ... data to create a Laporan
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Laporan we want to update
     *   }
     * })
    **/
    upsert<T extends LaporanUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, LaporanUpsertArgs<ExtArgs>>
    ): Prisma__LaporanClient<$Types.GetResult<LaporanPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Laporans.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaporanCountArgs} args - Arguments to filter Laporans to count.
     * @example
     * // Count the number of Laporans
     * const count = await prisma.laporan.count({
     *   where: {
     *     // ... the filter for the Laporans we want to count
     *   }
     * })
    **/
    count<T extends LaporanCountArgs>(
      args?: Subset<T, LaporanCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LaporanCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Laporan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaporanAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LaporanAggregateArgs>(args: Subset<T, LaporanAggregateArgs>): Prisma.PrismaPromise<GetLaporanAggregateType<T>>

    /**
     * Group by Laporan.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LaporanGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LaporanGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LaporanGroupByArgs['orderBy'] }
        : { orderBy?: LaporanGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LaporanGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLaporanGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Laporan model
   */
  readonly fields: LaporanFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Laporan.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LaporanClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    apoteker<T extends ApotekerArgs<ExtArgs> = {}>(args?: Subset<T, ApotekerArgs<ExtArgs>>): Prisma__ApotekerClient<$Types.GetResult<ApotekerPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    pemilik<T extends PemilikArgs<ExtArgs> = {}>(args?: Subset<T, PemilikArgs<ExtArgs>>): Prisma__PemilikClient<$Types.GetResult<PemilikPayload<ExtArgs>, T, 'findUnique'> | Null, never, ExtArgs>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Laporan model
   */ 
  interface LaporanFieldRefs {
    readonly id: FieldRef<"Laporan", 'String'>
    readonly isi_laporan: FieldRef<"Laporan", 'String'>
    readonly tanggal_laporan: FieldRef<"Laporan", 'String'>
    readonly id_apoteker: FieldRef<"Laporan", 'String'>
    readonly id_pemilik: FieldRef<"Laporan", 'Int'>
  }
    

  // Custom InputTypes

  /**
   * Laporan findUnique
   */
  export type LaporanFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
    /**
     * Filter, which Laporan to fetch.
     */
    where: LaporanWhereUniqueInput
  }


  /**
   * Laporan findUniqueOrThrow
   */
  export type LaporanFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
    /**
     * Filter, which Laporan to fetch.
     */
    where: LaporanWhereUniqueInput
  }


  /**
   * Laporan findFirst
   */
  export type LaporanFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
    /**
     * Filter, which Laporan to fetch.
     */
    where?: LaporanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Laporans to fetch.
     */
    orderBy?: LaporanOrderByWithRelationInput | LaporanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Laporans.
     */
    cursor?: LaporanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Laporans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Laporans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Laporans.
     */
    distinct?: LaporanScalarFieldEnum | LaporanScalarFieldEnum[]
  }


  /**
   * Laporan findFirstOrThrow
   */
  export type LaporanFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
    /**
     * Filter, which Laporan to fetch.
     */
    where?: LaporanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Laporans to fetch.
     */
    orderBy?: LaporanOrderByWithRelationInput | LaporanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Laporans.
     */
    cursor?: LaporanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Laporans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Laporans.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Laporans.
     */
    distinct?: LaporanScalarFieldEnum | LaporanScalarFieldEnum[]
  }


  /**
   * Laporan findMany
   */
  export type LaporanFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
    /**
     * Filter, which Laporans to fetch.
     */
    where?: LaporanWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Laporans to fetch.
     */
    orderBy?: LaporanOrderByWithRelationInput | LaporanOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Laporans.
     */
    cursor?: LaporanWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Laporans from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Laporans.
     */
    skip?: number
    distinct?: LaporanScalarFieldEnum | LaporanScalarFieldEnum[]
  }


  /**
   * Laporan create
   */
  export type LaporanCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
    /**
     * The data needed to create a Laporan.
     */
    data: XOR<LaporanCreateInput, LaporanUncheckedCreateInput>
  }


  /**
   * Laporan createMany
   */
  export type LaporanCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Laporans.
     */
    data: LaporanCreateManyInput | LaporanCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Laporan update
   */
  export type LaporanUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
    /**
     * The data needed to update a Laporan.
     */
    data: XOR<LaporanUpdateInput, LaporanUncheckedUpdateInput>
    /**
     * Choose, which Laporan to update.
     */
    where: LaporanWhereUniqueInput
  }


  /**
   * Laporan updateMany
   */
  export type LaporanUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Laporans.
     */
    data: XOR<LaporanUpdateManyMutationInput, LaporanUncheckedUpdateManyInput>
    /**
     * Filter which Laporans to update
     */
    where?: LaporanWhereInput
  }


  /**
   * Laporan upsert
   */
  export type LaporanUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
    /**
     * The filter to search for the Laporan to update in case it exists.
     */
    where: LaporanWhereUniqueInput
    /**
     * In case the Laporan found by the `where` argument doesn't exist, create a new Laporan with this data.
     */
    create: XOR<LaporanCreateInput, LaporanUncheckedCreateInput>
    /**
     * In case the Laporan was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LaporanUpdateInput, LaporanUncheckedUpdateInput>
  }


  /**
   * Laporan delete
   */
  export type LaporanDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
    /**
     * Filter which Laporan to delete.
     */
    where: LaporanWhereUniqueInput
  }


  /**
   * Laporan deleteMany
   */
  export type LaporanDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Laporans to delete
     */
    where?: LaporanWhereInput
  }


  /**
   * Laporan without action
   */
  export type LaporanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
  }



  /**
   * Model Pemilik
   */


  export type AggregatePemilik = {
    _count: PemilikCountAggregateOutputType | null
    _avg: PemilikAvgAggregateOutputType | null
    _sum: PemilikSumAggregateOutputType | null
    _min: PemilikMinAggregateOutputType | null
    _max: PemilikMaxAggregateOutputType | null
  }

  export type PemilikAvgAggregateOutputType = {
    id: number | null
  }

  export type PemilikSumAggregateOutputType = {
    id: number | null
  }

  export type PemilikMinAggregateOutputType = {
    id: number | null
    Nama: string | null
    Alamat: string | null
    no_telp: string | null
  }

  export type PemilikMaxAggregateOutputType = {
    id: number | null
    Nama: string | null
    Alamat: string | null
    no_telp: string | null
  }

  export type PemilikCountAggregateOutputType = {
    id: number
    Nama: number
    Alamat: number
    no_telp: number
    _all: number
  }


  export type PemilikAvgAggregateInputType = {
    id?: true
  }

  export type PemilikSumAggregateInputType = {
    id?: true
  }

  export type PemilikMinAggregateInputType = {
    id?: true
    Nama?: true
    Alamat?: true
    no_telp?: true
  }

  export type PemilikMaxAggregateInputType = {
    id?: true
    Nama?: true
    Alamat?: true
    no_telp?: true
  }

  export type PemilikCountAggregateInputType = {
    id?: true
    Nama?: true
    Alamat?: true
    no_telp?: true
    _all?: true
  }

  export type PemilikAggregateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pemilik to aggregate.
     */
    where?: PemilikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pemiliks to fetch.
     */
    orderBy?: PemilikOrderByWithRelationInput | PemilikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PemilikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pemiliks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pemiliks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Pemiliks
    **/
    _count?: true | PemilikCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PemilikAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PemilikSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PemilikMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PemilikMaxAggregateInputType
  }

  export type GetPemilikAggregateType<T extends PemilikAggregateArgs> = {
        [P in keyof T & keyof AggregatePemilik]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePemilik[P]>
      : GetScalarType<T[P], AggregatePemilik[P]>
  }




  export type PemilikGroupByArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    where?: PemilikWhereInput
    orderBy?: PemilikOrderByWithAggregationInput | PemilikOrderByWithAggregationInput[]
    by: PemilikScalarFieldEnum[] | PemilikScalarFieldEnum
    having?: PemilikScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PemilikCountAggregateInputType | true
    _avg?: PemilikAvgAggregateInputType
    _sum?: PemilikSumAggregateInputType
    _min?: PemilikMinAggregateInputType
    _max?: PemilikMaxAggregateInputType
  }


  export type PemilikGroupByOutputType = {
    id: number
    Nama: string | null
    Alamat: string | null
    no_telp: string | null
    _count: PemilikCountAggregateOutputType | null
    _avg: PemilikAvgAggregateOutputType | null
    _sum: PemilikSumAggregateOutputType | null
    _min: PemilikMinAggregateOutputType | null
    _max: PemilikMaxAggregateOutputType | null
  }

  type GetPemilikGroupByPayload<T extends PemilikGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PemilikGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PemilikGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PemilikGroupByOutputType[P]>
            : GetScalarType<T[P], PemilikGroupByOutputType[P]>
        }
      >
    >


  export type PemilikSelect<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    Nama?: boolean
    Alamat?: boolean
    no_telp?: boolean
    laporan?: boolean | Pemilik$laporanArgs<ExtArgs>
    _count?: boolean | PemilikCountOutputTypeArgs<ExtArgs>
  }, ExtArgs["result"]["pemilik"]>

  export type PemilikSelectScalar = {
    id?: boolean
    Nama?: boolean
    Alamat?: boolean
    no_telp?: boolean
  }

  export type PemilikInclude<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    laporan?: boolean | Pemilik$laporanArgs<ExtArgs>
    _count?: boolean | PemilikCountOutputTypeArgs<ExtArgs>
  }


  type PemilikGetPayload<S extends boolean | null | undefined | PemilikArgs> = $Types.GetResult<PemilikPayload, S>

  type PemilikCountArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = 
    Omit<PemilikFindManyArgs, 'select' | 'include'> & {
      select?: PemilikCountAggregateInputType | true
    }

  export interface PemilikDelegate<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Pemilik'], meta: { name: 'Pemilik' } }
    /**
     * Find zero or one Pemilik that matches the filter.
     * @param {PemilikFindUniqueArgs} args - Arguments to find a Pemilik
     * @example
     * // Get one Pemilik
     * const pemilik = await prisma.pemilik.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PemilikFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, PemilikFindUniqueArgs<ExtArgs>>
    ): Prisma__PemilikClient<$Types.GetResult<PemilikPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Pemilik that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {PemilikFindUniqueOrThrowArgs} args - Arguments to find a Pemilik
     * @example
     * // Get one Pemilik
     * const pemilik = await prisma.pemilik.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends PemilikFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PemilikFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__PemilikClient<$Types.GetResult<PemilikPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Pemilik that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PemilikFindFirstArgs} args - Arguments to find a Pemilik
     * @example
     * // Get one Pemilik
     * const pemilik = await prisma.pemilik.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PemilikFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, PemilikFindFirstArgs<ExtArgs>>
    ): Prisma__PemilikClient<$Types.GetResult<PemilikPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Pemilik that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PemilikFindFirstOrThrowArgs} args - Arguments to find a Pemilik
     * @example
     * // Get one Pemilik
     * const pemilik = await prisma.pemilik.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends PemilikFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, PemilikFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__PemilikClient<$Types.GetResult<PemilikPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Pemiliks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PemilikFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Pemiliks
     * const pemiliks = await prisma.pemilik.findMany()
     * 
     * // Get first 10 Pemiliks
     * const pemiliks = await prisma.pemilik.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pemilikWithIdOnly = await prisma.pemilik.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PemilikFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PemilikFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Types.GetResult<PemilikPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Pemilik.
     * @param {PemilikCreateArgs} args - Arguments to create a Pemilik.
     * @example
     * // Create one Pemilik
     * const Pemilik = await prisma.pemilik.create({
     *   data: {
     *     // ... data to create a Pemilik
     *   }
     * })
     * 
    **/
    create<T extends PemilikCreateArgs<ExtArgs>>(
      args: SelectSubset<T, PemilikCreateArgs<ExtArgs>>
    ): Prisma__PemilikClient<$Types.GetResult<PemilikPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Pemiliks.
     *     @param {PemilikCreateManyArgs} args - Arguments to create many Pemiliks.
     *     @example
     *     // Create many Pemiliks
     *     const pemilik = await prisma.pemilik.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PemilikCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PemilikCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Pemilik.
     * @param {PemilikDeleteArgs} args - Arguments to delete one Pemilik.
     * @example
     * // Delete one Pemilik
     * const Pemilik = await prisma.pemilik.delete({
     *   where: {
     *     // ... filter to delete one Pemilik
     *   }
     * })
     * 
    **/
    delete<T extends PemilikDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, PemilikDeleteArgs<ExtArgs>>
    ): Prisma__PemilikClient<$Types.GetResult<PemilikPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Pemilik.
     * @param {PemilikUpdateArgs} args - Arguments to update one Pemilik.
     * @example
     * // Update one Pemilik
     * const pemilik = await prisma.pemilik.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PemilikUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, PemilikUpdateArgs<ExtArgs>>
    ): Prisma__PemilikClient<$Types.GetResult<PemilikPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Pemiliks.
     * @param {PemilikDeleteManyArgs} args - Arguments to filter Pemiliks to delete.
     * @example
     * // Delete a few Pemiliks
     * const { count } = await prisma.pemilik.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PemilikDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, PemilikDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Pemiliks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PemilikUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Pemiliks
     * const pemilik = await prisma.pemilik.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PemilikUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, PemilikUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Pemilik.
     * @param {PemilikUpsertArgs} args - Arguments to update or create a Pemilik.
     * @example
     * // Update or create a Pemilik
     * const pemilik = await prisma.pemilik.upsert({
     *   create: {
     *     // ... data to create a Pemilik
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Pemilik we want to update
     *   }
     * })
    **/
    upsert<T extends PemilikUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, PemilikUpsertArgs<ExtArgs>>
    ): Prisma__PemilikClient<$Types.GetResult<PemilikPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Pemiliks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PemilikCountArgs} args - Arguments to filter Pemiliks to count.
     * @example
     * // Count the number of Pemiliks
     * const count = await prisma.pemilik.count({
     *   where: {
     *     // ... the filter for the Pemiliks we want to count
     *   }
     * })
    **/
    count<T extends PemilikCountArgs>(
      args?: Subset<T, PemilikCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PemilikCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Pemilik.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PemilikAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PemilikAggregateArgs>(args: Subset<T, PemilikAggregateArgs>): Prisma.PrismaPromise<GetPemilikAggregateType<T>>

    /**
     * Group by Pemilik.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PemilikGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PemilikGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PemilikGroupByArgs['orderBy'] }
        : { orderBy?: PemilikGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PemilikGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPemilikGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Pemilik model
   */
  readonly fields: PemilikFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Pemilik.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PemilikClient<T, Null = never, ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    laporan<T extends Pemilik$laporanArgs<ExtArgs> = {}>(args?: Subset<T, Pemilik$laporanArgs<ExtArgs>>): Prisma.PrismaPromise<$Types.GetResult<LaporanPayload<ExtArgs>, T, 'findMany'>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  /**
   * Fields of the Pemilik model
   */ 
  interface PemilikFieldRefs {
    readonly id: FieldRef<"Pemilik", 'Int'>
    readonly Nama: FieldRef<"Pemilik", 'String'>
    readonly Alamat: FieldRef<"Pemilik", 'String'>
    readonly no_telp: FieldRef<"Pemilik", 'String'>
  }
    

  // Custom InputTypes

  /**
   * Pemilik findUnique
   */
  export type PemilikFindUniqueArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pemilik
     */
    select?: PemilikSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PemilikInclude<ExtArgs> | null
    /**
     * Filter, which Pemilik to fetch.
     */
    where: PemilikWhereUniqueInput
  }


  /**
   * Pemilik findUniqueOrThrow
   */
  export type PemilikFindUniqueOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pemilik
     */
    select?: PemilikSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PemilikInclude<ExtArgs> | null
    /**
     * Filter, which Pemilik to fetch.
     */
    where: PemilikWhereUniqueInput
  }


  /**
   * Pemilik findFirst
   */
  export type PemilikFindFirstArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pemilik
     */
    select?: PemilikSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PemilikInclude<ExtArgs> | null
    /**
     * Filter, which Pemilik to fetch.
     */
    where?: PemilikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pemiliks to fetch.
     */
    orderBy?: PemilikOrderByWithRelationInput | PemilikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pemiliks.
     */
    cursor?: PemilikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pemiliks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pemiliks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pemiliks.
     */
    distinct?: PemilikScalarFieldEnum | PemilikScalarFieldEnum[]
  }


  /**
   * Pemilik findFirstOrThrow
   */
  export type PemilikFindFirstOrThrowArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pemilik
     */
    select?: PemilikSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PemilikInclude<ExtArgs> | null
    /**
     * Filter, which Pemilik to fetch.
     */
    where?: PemilikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pemiliks to fetch.
     */
    orderBy?: PemilikOrderByWithRelationInput | PemilikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Pemiliks.
     */
    cursor?: PemilikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pemiliks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pemiliks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Pemiliks.
     */
    distinct?: PemilikScalarFieldEnum | PemilikScalarFieldEnum[]
  }


  /**
   * Pemilik findMany
   */
  export type PemilikFindManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pemilik
     */
    select?: PemilikSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PemilikInclude<ExtArgs> | null
    /**
     * Filter, which Pemiliks to fetch.
     */
    where?: PemilikWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Pemiliks to fetch.
     */
    orderBy?: PemilikOrderByWithRelationInput | PemilikOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Pemiliks.
     */
    cursor?: PemilikWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Pemiliks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Pemiliks.
     */
    skip?: number
    distinct?: PemilikScalarFieldEnum | PemilikScalarFieldEnum[]
  }


  /**
   * Pemilik create
   */
  export type PemilikCreateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pemilik
     */
    select?: PemilikSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PemilikInclude<ExtArgs> | null
    /**
     * The data needed to create a Pemilik.
     */
    data: XOR<PemilikCreateInput, PemilikUncheckedCreateInput>
  }


  /**
   * Pemilik createMany
   */
  export type PemilikCreateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Pemiliks.
     */
    data: PemilikCreateManyInput | PemilikCreateManyInput[]
    skipDuplicates?: boolean
  }


  /**
   * Pemilik update
   */
  export type PemilikUpdateArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pemilik
     */
    select?: PemilikSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PemilikInclude<ExtArgs> | null
    /**
     * The data needed to update a Pemilik.
     */
    data: XOR<PemilikUpdateInput, PemilikUncheckedUpdateInput>
    /**
     * Choose, which Pemilik to update.
     */
    where: PemilikWhereUniqueInput
  }


  /**
   * Pemilik updateMany
   */
  export type PemilikUpdateManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Pemiliks.
     */
    data: XOR<PemilikUpdateManyMutationInput, PemilikUncheckedUpdateManyInput>
    /**
     * Filter which Pemiliks to update
     */
    where?: PemilikWhereInput
  }


  /**
   * Pemilik upsert
   */
  export type PemilikUpsertArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pemilik
     */
    select?: PemilikSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PemilikInclude<ExtArgs> | null
    /**
     * The filter to search for the Pemilik to update in case it exists.
     */
    where: PemilikWhereUniqueInput
    /**
     * In case the Pemilik found by the `where` argument doesn't exist, create a new Pemilik with this data.
     */
    create: XOR<PemilikCreateInput, PemilikUncheckedCreateInput>
    /**
     * In case the Pemilik was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PemilikUpdateInput, PemilikUncheckedUpdateInput>
  }


  /**
   * Pemilik delete
   */
  export type PemilikDeleteArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pemilik
     */
    select?: PemilikSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PemilikInclude<ExtArgs> | null
    /**
     * Filter which Pemilik to delete.
     */
    where: PemilikWhereUniqueInput
  }


  /**
   * Pemilik deleteMany
   */
  export type PemilikDeleteManyArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Filter which Pemiliks to delete
     */
    where?: PemilikWhereInput
  }


  /**
   * Pemilik.laporan
   */
  export type Pemilik$laporanArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Laporan
     */
    select?: LaporanSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: LaporanInclude<ExtArgs> | null
    where?: LaporanWhereInput
    orderBy?: LaporanOrderByWithRelationInput | LaporanOrderByWithRelationInput[]
    cursor?: LaporanWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LaporanScalarFieldEnum | LaporanScalarFieldEnum[]
  }


  /**
   * Pemilik without action
   */
  export type PemilikArgs<ExtArgs extends $Extensions.Args = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Pemilik
     */
    select?: PemilikSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: PemilikInclude<ExtArgs> | null
  }



  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ObatScalarFieldEnum: {
    id: 'id',
    nama_obat: 'nama_obat',
    gambar: 'gambar',
    jenis_obat: 'jenis_obat',
    tipe_obat: 'tipe_obat',
    tanggal_expired: 'tanggal_expired',
    jumlah: 'jumlah',
    harga_beli: 'harga_beli',
    harga_jual: 'harga_jual',
    stok_obat: 'stok_obat',
    kategori_obat: 'kategori_obat',
    sub_kategori: 'sub_kategori',
    created_at: 'created_at',
    updated_at: 'updated_at',
    id_staff: 'id_staff',
    id_supplier: 'id_supplier'
  };

  export type ObatScalarFieldEnum = (typeof ObatScalarFieldEnum)[keyof typeof ObatScalarFieldEnum]


  export const PembelianScalarFieldEnum: {
    id: 'id',
    jumlah_jual: 'jumlah_jual',
    total_harga: 'total_harga',
    tanggal_beli: 'tanggal_beli',
    jumlah_beli: 'jumlah_beli',
    id_pelanggan: 'id_pelanggan',
    id_apoteker: 'id_apoteker'
  };

  export type PembelianScalarFieldEnum = (typeof PembelianScalarFieldEnum)[keyof typeof PembelianScalarFieldEnum]


  export const Det_pembelianScalarFieldEnum: {
    id: 'id',
    id_faktur: 'id_faktur',
    id_obat: 'id_obat'
  };

  export type Det_pembelianScalarFieldEnum = (typeof Det_pembelianScalarFieldEnum)[keyof typeof Det_pembelianScalarFieldEnum]


  export const Staff_gudangScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    alamat: 'alamat',
    no_telp: 'no_telp'
  };

  export type Staff_gudangScalarFieldEnum = (typeof Staff_gudangScalarFieldEnum)[keyof typeof Staff_gudangScalarFieldEnum]


  export const SupplierScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    alamat: 'alamat',
    no_telp: 'no_telp'
  };

  export type SupplierScalarFieldEnum = (typeof SupplierScalarFieldEnum)[keyof typeof SupplierScalarFieldEnum]


  export const ApotekerScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    alamat: 'alamat',
    no_telp: 'no_telp'
  };

  export type ApotekerScalarFieldEnum = (typeof ApotekerScalarFieldEnum)[keyof typeof ApotekerScalarFieldEnum]


  export const PelangganScalarFieldEnum: {
    id: 'id',
    nama: 'nama',
    alamat: 'alamat',
    no_telp: 'no_telp'
  };

  export type PelangganScalarFieldEnum = (typeof PelangganScalarFieldEnum)[keyof typeof PelangganScalarFieldEnum]


  export const LaporanScalarFieldEnum: {
    id: 'id',
    isi_laporan: 'isi_laporan',
    tanggal_laporan: 'tanggal_laporan',
    id_apoteker: 'id_apoteker',
    id_pemilik: 'id_pemilik'
  };

  export type LaporanScalarFieldEnum = (typeof LaporanScalarFieldEnum)[keyof typeof LaporanScalarFieldEnum]


  export const PemilikScalarFieldEnum: {
    id: 'id',
    Nama: 'Nama',
    Alamat: 'Alamat',
    no_telp: 'no_telp'
  };

  export type PemilikScalarFieldEnum = (typeof PemilikScalarFieldEnum)[keyof typeof PemilikScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type ObatWhereInput = {
    AND?: ObatWhereInput | ObatWhereInput[]
    OR?: ObatWhereInput[]
    NOT?: ObatWhereInput | ObatWhereInput[]
    id?: StringFilter<"Obat"> | string
    nama_obat?: StringNullableFilter<"Obat"> | string | null
    gambar?: StringNullableFilter<"Obat"> | string | null
    jenis_obat?: StringNullableFilter<"Obat"> | string | null
    tipe_obat?: StringNullableFilter<"Obat"> | string | null
    tanggal_expired?: StringNullableFilter<"Obat"> | string | null
    jumlah?: IntNullableFilter<"Obat"> | number | null
    harga_beli?: IntFilter<"Obat"> | number
    harga_jual?: IntFilter<"Obat"> | number
    stok_obat?: IntNullableFilter<"Obat"> | number | null
    kategori_obat?: StringNullableFilter<"Obat"> | string | null
    sub_kategori?: StringNullableFilter<"Obat"> | string | null
    created_at?: DateTimeFilter<"Obat"> | Date | string
    updated_at?: DateTimeFilter<"Obat"> | Date | string
    id_staff?: StringFilter<"Obat"> | string
    id_supplier?: StringFilter<"Obat"> | string
    staff?: XOR<Staff_gudangRelationFilter, Staff_gudangWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    det_pembelian?: Det_pembelianListRelationFilter
  }

  export type ObatOrderByWithRelationInput = {
    id?: SortOrder
    nama_obat?: SortOrderInput | SortOrder
    gambar?: SortOrderInput | SortOrder
    jenis_obat?: SortOrderInput | SortOrder
    tipe_obat?: SortOrderInput | SortOrder
    tanggal_expired?: SortOrderInput | SortOrder
    jumlah?: SortOrderInput | SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    stok_obat?: SortOrderInput | SortOrder
    kategori_obat?: SortOrderInput | SortOrder
    sub_kategori?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id_staff?: SortOrder
    id_supplier?: SortOrder
    staff?: Staff_gudangOrderByWithRelationInput
    supplier?: SupplierOrderByWithRelationInput
    det_pembelian?: Det_pembelianOrderByRelationAggregateInput
  }

  export type ObatWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ObatWhereInput | ObatWhereInput[]
    OR?: ObatWhereInput[]
    NOT?: ObatWhereInput | ObatWhereInput[]
    nama_obat?: StringNullableFilter<"Obat"> | string | null
    gambar?: StringNullableFilter<"Obat"> | string | null
    jenis_obat?: StringNullableFilter<"Obat"> | string | null
    tipe_obat?: StringNullableFilter<"Obat"> | string | null
    tanggal_expired?: StringNullableFilter<"Obat"> | string | null
    jumlah?: IntNullableFilter<"Obat"> | number | null
    harga_beli?: IntFilter<"Obat"> | number
    harga_jual?: IntFilter<"Obat"> | number
    stok_obat?: IntNullableFilter<"Obat"> | number | null
    kategori_obat?: StringNullableFilter<"Obat"> | string | null
    sub_kategori?: StringNullableFilter<"Obat"> | string | null
    created_at?: DateTimeFilter<"Obat"> | Date | string
    updated_at?: DateTimeFilter<"Obat"> | Date | string
    id_staff?: StringFilter<"Obat"> | string
    id_supplier?: StringFilter<"Obat"> | string
    staff?: XOR<Staff_gudangRelationFilter, Staff_gudangWhereInput>
    supplier?: XOR<SupplierRelationFilter, SupplierWhereInput>
    det_pembelian?: Det_pembelianListRelationFilter
  }, "id">

  export type ObatOrderByWithAggregationInput = {
    id?: SortOrder
    nama_obat?: SortOrderInput | SortOrder
    gambar?: SortOrderInput | SortOrder
    jenis_obat?: SortOrderInput | SortOrder
    tipe_obat?: SortOrderInput | SortOrder
    tanggal_expired?: SortOrderInput | SortOrder
    jumlah?: SortOrderInput | SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    stok_obat?: SortOrderInput | SortOrder
    kategori_obat?: SortOrderInput | SortOrder
    sub_kategori?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id_staff?: SortOrder
    id_supplier?: SortOrder
    _count?: ObatCountOrderByAggregateInput
    _avg?: ObatAvgOrderByAggregateInput
    _max?: ObatMaxOrderByAggregateInput
    _min?: ObatMinOrderByAggregateInput
    _sum?: ObatSumOrderByAggregateInput
  }

  export type ObatScalarWhereWithAggregatesInput = {
    AND?: ObatScalarWhereWithAggregatesInput | ObatScalarWhereWithAggregatesInput[]
    OR?: ObatScalarWhereWithAggregatesInput[]
    NOT?: ObatScalarWhereWithAggregatesInput | ObatScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Obat"> | string
    nama_obat?: StringNullableWithAggregatesFilter<"Obat"> | string | null
    gambar?: StringNullableWithAggregatesFilter<"Obat"> | string | null
    jenis_obat?: StringNullableWithAggregatesFilter<"Obat"> | string | null
    tipe_obat?: StringNullableWithAggregatesFilter<"Obat"> | string | null
    tanggal_expired?: StringNullableWithAggregatesFilter<"Obat"> | string | null
    jumlah?: IntNullableWithAggregatesFilter<"Obat"> | number | null
    harga_beli?: IntWithAggregatesFilter<"Obat"> | number
    harga_jual?: IntWithAggregatesFilter<"Obat"> | number
    stok_obat?: IntNullableWithAggregatesFilter<"Obat"> | number | null
    kategori_obat?: StringNullableWithAggregatesFilter<"Obat"> | string | null
    sub_kategori?: StringNullableWithAggregatesFilter<"Obat"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Obat"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Obat"> | Date | string
    id_staff?: StringWithAggregatesFilter<"Obat"> | string
    id_supplier?: StringWithAggregatesFilter<"Obat"> | string
  }

  export type PembelianWhereInput = {
    AND?: PembelianWhereInput | PembelianWhereInput[]
    OR?: PembelianWhereInput[]
    NOT?: PembelianWhereInput | PembelianWhereInput[]
    id?: StringFilter<"Pembelian"> | string
    jumlah_jual?: IntNullableFilter<"Pembelian"> | number | null
    total_harga?: IntFilter<"Pembelian"> | number
    tanggal_beli?: DateTimeNullableFilter<"Pembelian"> | Date | string | null
    jumlah_beli?: StringNullableFilter<"Pembelian"> | string | null
    id_pelanggan?: StringFilter<"Pembelian"> | string
    id_apoteker?: StringFilter<"Pembelian"> | string
    pelanggan?: XOR<PelangganRelationFilter, PelangganWhereInput>
    apoteker?: XOR<ApotekerRelationFilter, ApotekerWhereInput>
    det_pembelian?: Det_pembelianListRelationFilter
  }

  export type PembelianOrderByWithRelationInput = {
    id?: SortOrder
    jumlah_jual?: SortOrderInput | SortOrder
    total_harga?: SortOrder
    tanggal_beli?: SortOrderInput | SortOrder
    jumlah_beli?: SortOrderInput | SortOrder
    id_pelanggan?: SortOrder
    id_apoteker?: SortOrder
    pelanggan?: PelangganOrderByWithRelationInput
    apoteker?: ApotekerOrderByWithRelationInput
    det_pembelian?: Det_pembelianOrderByRelationAggregateInput
  }

  export type PembelianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PembelianWhereInput | PembelianWhereInput[]
    OR?: PembelianWhereInput[]
    NOT?: PembelianWhereInput | PembelianWhereInput[]
    jumlah_jual?: IntNullableFilter<"Pembelian"> | number | null
    total_harga?: IntFilter<"Pembelian"> | number
    tanggal_beli?: DateTimeNullableFilter<"Pembelian"> | Date | string | null
    jumlah_beli?: StringNullableFilter<"Pembelian"> | string | null
    id_pelanggan?: StringFilter<"Pembelian"> | string
    id_apoteker?: StringFilter<"Pembelian"> | string
    pelanggan?: XOR<PelangganRelationFilter, PelangganWhereInput>
    apoteker?: XOR<ApotekerRelationFilter, ApotekerWhereInput>
    det_pembelian?: Det_pembelianListRelationFilter
  }, "id">

  export type PembelianOrderByWithAggregationInput = {
    id?: SortOrder
    jumlah_jual?: SortOrderInput | SortOrder
    total_harga?: SortOrder
    tanggal_beli?: SortOrderInput | SortOrder
    jumlah_beli?: SortOrderInput | SortOrder
    id_pelanggan?: SortOrder
    id_apoteker?: SortOrder
    _count?: PembelianCountOrderByAggregateInput
    _avg?: PembelianAvgOrderByAggregateInput
    _max?: PembelianMaxOrderByAggregateInput
    _min?: PembelianMinOrderByAggregateInput
    _sum?: PembelianSumOrderByAggregateInput
  }

  export type PembelianScalarWhereWithAggregatesInput = {
    AND?: PembelianScalarWhereWithAggregatesInput | PembelianScalarWhereWithAggregatesInput[]
    OR?: PembelianScalarWhereWithAggregatesInput[]
    NOT?: PembelianScalarWhereWithAggregatesInput | PembelianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pembelian"> | string
    jumlah_jual?: IntNullableWithAggregatesFilter<"Pembelian"> | number | null
    total_harga?: IntWithAggregatesFilter<"Pembelian"> | number
    tanggal_beli?: DateTimeNullableWithAggregatesFilter<"Pembelian"> | Date | string | null
    jumlah_beli?: StringNullableWithAggregatesFilter<"Pembelian"> | string | null
    id_pelanggan?: StringWithAggregatesFilter<"Pembelian"> | string
    id_apoteker?: StringWithAggregatesFilter<"Pembelian"> | string
  }

  export type Det_pembelianWhereInput = {
    AND?: Det_pembelianWhereInput | Det_pembelianWhereInput[]
    OR?: Det_pembelianWhereInput[]
    NOT?: Det_pembelianWhereInput | Det_pembelianWhereInput[]
    id?: StringFilter<"Det_pembelian"> | string
    id_faktur?: StringFilter<"Det_pembelian"> | string
    id_obat?: StringFilter<"Det_pembelian"> | string
    pembelian?: XOR<PembelianRelationFilter, PembelianWhereInput>
    obat?: XOR<ObatRelationFilter, ObatWhereInput>
  }

  export type Det_pembelianOrderByWithRelationInput = {
    id?: SortOrder
    id_faktur?: SortOrder
    id_obat?: SortOrder
    pembelian?: PembelianOrderByWithRelationInput
    obat?: ObatOrderByWithRelationInput
  }

  export type Det_pembelianWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Det_pembelianWhereInput | Det_pembelianWhereInput[]
    OR?: Det_pembelianWhereInput[]
    NOT?: Det_pembelianWhereInput | Det_pembelianWhereInput[]
    id_faktur?: StringFilter<"Det_pembelian"> | string
    id_obat?: StringFilter<"Det_pembelian"> | string
    pembelian?: XOR<PembelianRelationFilter, PembelianWhereInput>
    obat?: XOR<ObatRelationFilter, ObatWhereInput>
  }, "id">

  export type Det_pembelianOrderByWithAggregationInput = {
    id?: SortOrder
    id_faktur?: SortOrder
    id_obat?: SortOrder
    _count?: Det_pembelianCountOrderByAggregateInput
    _max?: Det_pembelianMaxOrderByAggregateInput
    _min?: Det_pembelianMinOrderByAggregateInput
  }

  export type Det_pembelianScalarWhereWithAggregatesInput = {
    AND?: Det_pembelianScalarWhereWithAggregatesInput | Det_pembelianScalarWhereWithAggregatesInput[]
    OR?: Det_pembelianScalarWhereWithAggregatesInput[]
    NOT?: Det_pembelianScalarWhereWithAggregatesInput | Det_pembelianScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Det_pembelian"> | string
    id_faktur?: StringWithAggregatesFilter<"Det_pembelian"> | string
    id_obat?: StringWithAggregatesFilter<"Det_pembelian"> | string
  }

  export type Staff_gudangWhereInput = {
    AND?: Staff_gudangWhereInput | Staff_gudangWhereInput[]
    OR?: Staff_gudangWhereInput[]
    NOT?: Staff_gudangWhereInput | Staff_gudangWhereInput[]
    id?: StringFilter<"Staff_gudang"> | string
    nama?: StringNullableFilter<"Staff_gudang"> | string | null
    alamat?: StringNullableFilter<"Staff_gudang"> | string | null
    no_telp?: StringNullableFilter<"Staff_gudang"> | string | null
    Obat?: ObatListRelationFilter
  }

  export type Staff_gudangOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrderInput | SortOrder
    alamat?: SortOrderInput | SortOrder
    no_telp?: SortOrderInput | SortOrder
    Obat?: ObatOrderByRelationAggregateInput
  }

  export type Staff_gudangWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: Staff_gudangWhereInput | Staff_gudangWhereInput[]
    OR?: Staff_gudangWhereInput[]
    NOT?: Staff_gudangWhereInput | Staff_gudangWhereInput[]
    nama?: StringNullableFilter<"Staff_gudang"> | string | null
    alamat?: StringNullableFilter<"Staff_gudang"> | string | null
    no_telp?: StringNullableFilter<"Staff_gudang"> | string | null
    Obat?: ObatListRelationFilter
  }, "id">

  export type Staff_gudangOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrderInput | SortOrder
    alamat?: SortOrderInput | SortOrder
    no_telp?: SortOrderInput | SortOrder
    _count?: Staff_gudangCountOrderByAggregateInput
    _max?: Staff_gudangMaxOrderByAggregateInput
    _min?: Staff_gudangMinOrderByAggregateInput
  }

  export type Staff_gudangScalarWhereWithAggregatesInput = {
    AND?: Staff_gudangScalarWhereWithAggregatesInput | Staff_gudangScalarWhereWithAggregatesInput[]
    OR?: Staff_gudangScalarWhereWithAggregatesInput[]
    NOT?: Staff_gudangScalarWhereWithAggregatesInput | Staff_gudangScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Staff_gudang"> | string
    nama?: StringNullableWithAggregatesFilter<"Staff_gudang"> | string | null
    alamat?: StringNullableWithAggregatesFilter<"Staff_gudang"> | string | null
    no_telp?: StringNullableWithAggregatesFilter<"Staff_gudang"> | string | null
  }

  export type SupplierWhereInput = {
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    id?: StringFilter<"Supplier"> | string
    nama?: StringNullableFilter<"Supplier"> | string | null
    alamat?: StringNullableFilter<"Supplier"> | string | null
    no_telp?: StringNullableFilter<"Supplier"> | string | null
    Obat?: ObatListRelationFilter
  }

  export type SupplierOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrderInput | SortOrder
    alamat?: SortOrderInput | SortOrder
    no_telp?: SortOrderInput | SortOrder
    Obat?: ObatOrderByRelationAggregateInput
  }

  export type SupplierWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupplierWhereInput | SupplierWhereInput[]
    OR?: SupplierWhereInput[]
    NOT?: SupplierWhereInput | SupplierWhereInput[]
    nama?: StringNullableFilter<"Supplier"> | string | null
    alamat?: StringNullableFilter<"Supplier"> | string | null
    no_telp?: StringNullableFilter<"Supplier"> | string | null
    Obat?: ObatListRelationFilter
  }, "id">

  export type SupplierOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrderInput | SortOrder
    alamat?: SortOrderInput | SortOrder
    no_telp?: SortOrderInput | SortOrder
    _count?: SupplierCountOrderByAggregateInput
    _max?: SupplierMaxOrderByAggregateInput
    _min?: SupplierMinOrderByAggregateInput
  }

  export type SupplierScalarWhereWithAggregatesInput = {
    AND?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    OR?: SupplierScalarWhereWithAggregatesInput[]
    NOT?: SupplierScalarWhereWithAggregatesInput | SupplierScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Supplier"> | string
    nama?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    alamat?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
    no_telp?: StringNullableWithAggregatesFilter<"Supplier"> | string | null
  }

  export type ApotekerWhereInput = {
    AND?: ApotekerWhereInput | ApotekerWhereInput[]
    OR?: ApotekerWhereInput[]
    NOT?: ApotekerWhereInput | ApotekerWhereInput[]
    id?: StringFilter<"Apoteker"> | string
    nama?: StringNullableFilter<"Apoteker"> | string | null
    alamat?: StringNullableFilter<"Apoteker"> | string | null
    no_telp?: StringNullableFilter<"Apoteker"> | string | null
    laporan?: LaporanListRelationFilter
    pembelian?: PembelianListRelationFilter
  }

  export type ApotekerOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrderInput | SortOrder
    alamat?: SortOrderInput | SortOrder
    no_telp?: SortOrderInput | SortOrder
    laporan?: LaporanOrderByRelationAggregateInput
    pembelian?: PembelianOrderByRelationAggregateInput
  }

  export type ApotekerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ApotekerWhereInput | ApotekerWhereInput[]
    OR?: ApotekerWhereInput[]
    NOT?: ApotekerWhereInput | ApotekerWhereInput[]
    nama?: StringNullableFilter<"Apoteker"> | string | null
    alamat?: StringNullableFilter<"Apoteker"> | string | null
    no_telp?: StringNullableFilter<"Apoteker"> | string | null
    laporan?: LaporanListRelationFilter
    pembelian?: PembelianListRelationFilter
  }, "id">

  export type ApotekerOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrderInput | SortOrder
    alamat?: SortOrderInput | SortOrder
    no_telp?: SortOrderInput | SortOrder
    _count?: ApotekerCountOrderByAggregateInput
    _max?: ApotekerMaxOrderByAggregateInput
    _min?: ApotekerMinOrderByAggregateInput
  }

  export type ApotekerScalarWhereWithAggregatesInput = {
    AND?: ApotekerScalarWhereWithAggregatesInput | ApotekerScalarWhereWithAggregatesInput[]
    OR?: ApotekerScalarWhereWithAggregatesInput[]
    NOT?: ApotekerScalarWhereWithAggregatesInput | ApotekerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Apoteker"> | string
    nama?: StringNullableWithAggregatesFilter<"Apoteker"> | string | null
    alamat?: StringNullableWithAggregatesFilter<"Apoteker"> | string | null
    no_telp?: StringNullableWithAggregatesFilter<"Apoteker"> | string | null
  }

  export type PelangganWhereInput = {
    AND?: PelangganWhereInput | PelangganWhereInput[]
    OR?: PelangganWhereInput[]
    NOT?: PelangganWhereInput | PelangganWhereInput[]
    id?: StringFilter<"Pelanggan"> | string
    nama?: StringNullableFilter<"Pelanggan"> | string | null
    alamat?: StringNullableFilter<"Pelanggan"> | string | null
    no_telp?: StringNullableFilter<"Pelanggan"> | string | null
    pembelian?: PembelianListRelationFilter
  }

  export type PelangganOrderByWithRelationInput = {
    id?: SortOrder
    nama?: SortOrderInput | SortOrder
    alamat?: SortOrderInput | SortOrder
    no_telp?: SortOrderInput | SortOrder
    pembelian?: PembelianOrderByRelationAggregateInput
  }

  export type PelangganWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PelangganWhereInput | PelangganWhereInput[]
    OR?: PelangganWhereInput[]
    NOT?: PelangganWhereInput | PelangganWhereInput[]
    nama?: StringNullableFilter<"Pelanggan"> | string | null
    alamat?: StringNullableFilter<"Pelanggan"> | string | null
    no_telp?: StringNullableFilter<"Pelanggan"> | string | null
    pembelian?: PembelianListRelationFilter
  }, "id">

  export type PelangganOrderByWithAggregationInput = {
    id?: SortOrder
    nama?: SortOrderInput | SortOrder
    alamat?: SortOrderInput | SortOrder
    no_telp?: SortOrderInput | SortOrder
    _count?: PelangganCountOrderByAggregateInput
    _max?: PelangganMaxOrderByAggregateInput
    _min?: PelangganMinOrderByAggregateInput
  }

  export type PelangganScalarWhereWithAggregatesInput = {
    AND?: PelangganScalarWhereWithAggregatesInput | PelangganScalarWhereWithAggregatesInput[]
    OR?: PelangganScalarWhereWithAggregatesInput[]
    NOT?: PelangganScalarWhereWithAggregatesInput | PelangganScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Pelanggan"> | string
    nama?: StringNullableWithAggregatesFilter<"Pelanggan"> | string | null
    alamat?: StringNullableWithAggregatesFilter<"Pelanggan"> | string | null
    no_telp?: StringNullableWithAggregatesFilter<"Pelanggan"> | string | null
  }

  export type LaporanWhereInput = {
    AND?: LaporanWhereInput | LaporanWhereInput[]
    OR?: LaporanWhereInput[]
    NOT?: LaporanWhereInput | LaporanWhereInput[]
    id?: StringFilter<"Laporan"> | string
    isi_laporan?: StringFilter<"Laporan"> | string
    tanggal_laporan?: StringFilter<"Laporan"> | string
    id_apoteker?: StringFilter<"Laporan"> | string
    id_pemilik?: IntFilter<"Laporan"> | number
    apoteker?: XOR<ApotekerRelationFilter, ApotekerWhereInput>
    pemilik?: XOR<PemilikRelationFilter, PemilikWhereInput>
  }

  export type LaporanOrderByWithRelationInput = {
    id?: SortOrder
    isi_laporan?: SortOrder
    tanggal_laporan?: SortOrder
    id_apoteker?: SortOrder
    id_pemilik?: SortOrder
    apoteker?: ApotekerOrderByWithRelationInput
    pemilik?: PemilikOrderByWithRelationInput
  }

  export type LaporanWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LaporanWhereInput | LaporanWhereInput[]
    OR?: LaporanWhereInput[]
    NOT?: LaporanWhereInput | LaporanWhereInput[]
    isi_laporan?: StringFilter<"Laporan"> | string
    tanggal_laporan?: StringFilter<"Laporan"> | string
    id_apoteker?: StringFilter<"Laporan"> | string
    id_pemilik?: IntFilter<"Laporan"> | number
    apoteker?: XOR<ApotekerRelationFilter, ApotekerWhereInput>
    pemilik?: XOR<PemilikRelationFilter, PemilikWhereInput>
  }, "id">

  export type LaporanOrderByWithAggregationInput = {
    id?: SortOrder
    isi_laporan?: SortOrder
    tanggal_laporan?: SortOrder
    id_apoteker?: SortOrder
    id_pemilik?: SortOrder
    _count?: LaporanCountOrderByAggregateInput
    _avg?: LaporanAvgOrderByAggregateInput
    _max?: LaporanMaxOrderByAggregateInput
    _min?: LaporanMinOrderByAggregateInput
    _sum?: LaporanSumOrderByAggregateInput
  }

  export type LaporanScalarWhereWithAggregatesInput = {
    AND?: LaporanScalarWhereWithAggregatesInput | LaporanScalarWhereWithAggregatesInput[]
    OR?: LaporanScalarWhereWithAggregatesInput[]
    NOT?: LaporanScalarWhereWithAggregatesInput | LaporanScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Laporan"> | string
    isi_laporan?: StringWithAggregatesFilter<"Laporan"> | string
    tanggal_laporan?: StringWithAggregatesFilter<"Laporan"> | string
    id_apoteker?: StringWithAggregatesFilter<"Laporan"> | string
    id_pemilik?: IntWithAggregatesFilter<"Laporan"> | number
  }

  export type PemilikWhereInput = {
    AND?: PemilikWhereInput | PemilikWhereInput[]
    OR?: PemilikWhereInput[]
    NOT?: PemilikWhereInput | PemilikWhereInput[]
    id?: IntFilter<"Pemilik"> | number
    Nama?: StringNullableFilter<"Pemilik"> | string | null
    Alamat?: StringNullableFilter<"Pemilik"> | string | null
    no_telp?: StringNullableFilter<"Pemilik"> | string | null
    laporan?: LaporanListRelationFilter
  }

  export type PemilikOrderByWithRelationInput = {
    id?: SortOrder
    Nama?: SortOrderInput | SortOrder
    Alamat?: SortOrderInput | SortOrder
    no_telp?: SortOrderInput | SortOrder
    laporan?: LaporanOrderByRelationAggregateInput
  }

  export type PemilikWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: PemilikWhereInput | PemilikWhereInput[]
    OR?: PemilikWhereInput[]
    NOT?: PemilikWhereInput | PemilikWhereInput[]
    Nama?: StringNullableFilter<"Pemilik"> | string | null
    Alamat?: StringNullableFilter<"Pemilik"> | string | null
    no_telp?: StringNullableFilter<"Pemilik"> | string | null
    laporan?: LaporanListRelationFilter
  }, "id">

  export type PemilikOrderByWithAggregationInput = {
    id?: SortOrder
    Nama?: SortOrderInput | SortOrder
    Alamat?: SortOrderInput | SortOrder
    no_telp?: SortOrderInput | SortOrder
    _count?: PemilikCountOrderByAggregateInput
    _avg?: PemilikAvgOrderByAggregateInput
    _max?: PemilikMaxOrderByAggregateInput
    _min?: PemilikMinOrderByAggregateInput
    _sum?: PemilikSumOrderByAggregateInput
  }

  export type PemilikScalarWhereWithAggregatesInput = {
    AND?: PemilikScalarWhereWithAggregatesInput | PemilikScalarWhereWithAggregatesInput[]
    OR?: PemilikScalarWhereWithAggregatesInput[]
    NOT?: PemilikScalarWhereWithAggregatesInput | PemilikScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Pemilik"> | number
    Nama?: StringNullableWithAggregatesFilter<"Pemilik"> | string | null
    Alamat?: StringNullableWithAggregatesFilter<"Pemilik"> | string | null
    no_telp?: StringNullableWithAggregatesFilter<"Pemilik"> | string | null
  }

  export type ObatCreateInput = {
    id: string
    nama_obat?: string | null
    gambar?: string | null
    jenis_obat?: string | null
    tipe_obat?: string | null
    tanggal_expired?: string | null
    jumlah?: number | null
    harga_beli: number
    harga_jual: number
    stok_obat?: number | null
    kategori_obat?: string | null
    sub_kategori?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    staff: Staff_gudangCreateNestedOneWithoutObatInput
    supplier: SupplierCreateNestedOneWithoutObatInput
    det_pembelian?: Det_pembelianCreateNestedManyWithoutObatInput
  }

  export type ObatUncheckedCreateInput = {
    id: string
    nama_obat?: string | null
    gambar?: string | null
    jenis_obat?: string | null
    tipe_obat?: string | null
    tanggal_expired?: string | null
    jumlah?: number | null
    harga_beli: number
    harga_jual: number
    stok_obat?: number | null
    kategori_obat?: string | null
    sub_kategori?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    id_staff: string
    id_supplier: string
    det_pembelian?: Det_pembelianUncheckedCreateNestedManyWithoutObatInput
  }

  export type ObatUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: Staff_gudangUpdateOneRequiredWithoutObatNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutObatNestedInput
    det_pembelian?: Det_pembelianUpdateManyWithoutObatNestedInput
  }

  export type ObatUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_staff?: StringFieldUpdateOperationsInput | string
    id_supplier?: StringFieldUpdateOperationsInput | string
    det_pembelian?: Det_pembelianUncheckedUpdateManyWithoutObatNestedInput
  }

  export type ObatCreateManyInput = {
    id: string
    nama_obat?: string | null
    gambar?: string | null
    jenis_obat?: string | null
    tipe_obat?: string | null
    tanggal_expired?: string | null
    jumlah?: number | null
    harga_beli: number
    harga_jual: number
    stok_obat?: number | null
    kategori_obat?: string | null
    sub_kategori?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    id_staff: string
    id_supplier: string
  }

  export type ObatUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ObatUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_staff?: StringFieldUpdateOperationsInput | string
    id_supplier?: StringFieldUpdateOperationsInput | string
  }

  export type PembelianCreateInput = {
    id: string
    jumlah_jual?: number | null
    total_harga: number
    tanggal_beli?: Date | string | null
    jumlah_beli?: string | null
    pelanggan: PelangganCreateNestedOneWithoutPembelianInput
    apoteker: ApotekerCreateNestedOneWithoutPembelianInput
    det_pembelian?: Det_pembelianCreateNestedManyWithoutPembelianInput
  }

  export type PembelianUncheckedCreateInput = {
    id: string
    jumlah_jual?: number | null
    total_harga: number
    tanggal_beli?: Date | string | null
    jumlah_beli?: string | null
    id_pelanggan: string
    id_apoteker: string
    det_pembelian?: Det_pembelianUncheckedCreateNestedManyWithoutPembelianInput
  }

  export type PembelianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
    pelanggan?: PelangganUpdateOneRequiredWithoutPembelianNestedInput
    apoteker?: ApotekerUpdateOneRequiredWithoutPembelianNestedInput
    det_pembelian?: Det_pembelianUpdateManyWithoutPembelianNestedInput
  }

  export type PembelianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
    id_pelanggan?: StringFieldUpdateOperationsInput | string
    id_apoteker?: StringFieldUpdateOperationsInput | string
    det_pembelian?: Det_pembelianUncheckedUpdateManyWithoutPembelianNestedInput
  }

  export type PembelianCreateManyInput = {
    id: string
    jumlah_jual?: number | null
    total_harga: number
    tanggal_beli?: Date | string | null
    jumlah_beli?: string | null
    id_pelanggan: string
    id_apoteker: string
  }

  export type PembelianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PembelianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
    id_pelanggan?: StringFieldUpdateOperationsInput | string
    id_apoteker?: StringFieldUpdateOperationsInput | string
  }

  export type Det_pembelianCreateInput = {
    id: string
    pembelian: PembelianCreateNestedOneWithoutDet_pembelianInput
    obat: ObatCreateNestedOneWithoutDet_pembelianInput
  }

  export type Det_pembelianUncheckedCreateInput = {
    id: string
    id_faktur: string
    id_obat: string
  }

  export type Det_pembelianUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pembelian?: PembelianUpdateOneRequiredWithoutDet_pembelianNestedInput
    obat?: ObatUpdateOneRequiredWithoutDet_pembelianNestedInput
  }

  export type Det_pembelianUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_faktur?: StringFieldUpdateOperationsInput | string
    id_obat?: StringFieldUpdateOperationsInput | string
  }

  export type Det_pembelianCreateManyInput = {
    id: string
    id_faktur: string
    id_obat: string
  }

  export type Det_pembelianUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type Det_pembelianUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_faktur?: StringFieldUpdateOperationsInput | string
    id_obat?: StringFieldUpdateOperationsInput | string
  }

  export type Staff_gudangCreateInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    Obat?: ObatCreateNestedManyWithoutStaffInput
  }

  export type Staff_gudangUncheckedCreateInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    Obat?: ObatUncheckedCreateNestedManyWithoutStaffInput
  }

  export type Staff_gudangUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    Obat?: ObatUpdateManyWithoutStaffNestedInput
  }

  export type Staff_gudangUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    Obat?: ObatUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type Staff_gudangCreateManyInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
  }

  export type Staff_gudangUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Staff_gudangUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierCreateInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    Obat?: ObatCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUncheckedCreateInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    Obat?: ObatUncheckedCreateNestedManyWithoutSupplierInput
  }

  export type SupplierUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    Obat?: ObatUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    Obat?: ObatUncheckedUpdateManyWithoutSupplierNestedInput
  }

  export type SupplierCreateManyInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
  }

  export type SupplierUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApotekerCreateInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    laporan?: LaporanCreateNestedManyWithoutApotekerInput
    pembelian?: PembelianCreateNestedManyWithoutApotekerInput
  }

  export type ApotekerUncheckedCreateInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    laporan?: LaporanUncheckedCreateNestedManyWithoutApotekerInput
    pembelian?: PembelianUncheckedCreateNestedManyWithoutApotekerInput
  }

  export type ApotekerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    laporan?: LaporanUpdateManyWithoutApotekerNestedInput
    pembelian?: PembelianUpdateManyWithoutApotekerNestedInput
  }

  export type ApotekerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    laporan?: LaporanUncheckedUpdateManyWithoutApotekerNestedInput
    pembelian?: PembelianUncheckedUpdateManyWithoutApotekerNestedInput
  }

  export type ApotekerCreateManyInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
  }

  export type ApotekerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApotekerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PelangganCreateInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    pembelian?: PembelianCreateNestedManyWithoutPelangganInput
  }

  export type PelangganUncheckedCreateInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    pembelian?: PembelianUncheckedCreateNestedManyWithoutPelangganInput
  }

  export type PelangganUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    pembelian?: PembelianUpdateManyWithoutPelangganNestedInput
  }

  export type PelangganUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    pembelian?: PembelianUncheckedUpdateManyWithoutPelangganNestedInput
  }

  export type PelangganCreateManyInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
  }

  export type PelangganUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PelangganUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaporanCreateInput = {
    id: string
    isi_laporan: string
    tanggal_laporan: string
    apoteker: ApotekerCreateNestedOneWithoutLaporanInput
    pemilik: PemilikCreateNestedOneWithoutLaporanInput
  }

  export type LaporanUncheckedCreateInput = {
    id: string
    isi_laporan: string
    tanggal_laporan: string
    id_apoteker: string
    id_pemilik: number
  }

  export type LaporanUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isi_laporan?: StringFieldUpdateOperationsInput | string
    tanggal_laporan?: StringFieldUpdateOperationsInput | string
    apoteker?: ApotekerUpdateOneRequiredWithoutLaporanNestedInput
    pemilik?: PemilikUpdateOneRequiredWithoutLaporanNestedInput
  }

  export type LaporanUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isi_laporan?: StringFieldUpdateOperationsInput | string
    tanggal_laporan?: StringFieldUpdateOperationsInput | string
    id_apoteker?: StringFieldUpdateOperationsInput | string
    id_pemilik?: IntFieldUpdateOperationsInput | number
  }

  export type LaporanCreateManyInput = {
    id: string
    isi_laporan: string
    tanggal_laporan: string
    id_apoteker: string
    id_pemilik: number
  }

  export type LaporanUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isi_laporan?: StringFieldUpdateOperationsInput | string
    tanggal_laporan?: StringFieldUpdateOperationsInput | string
  }

  export type LaporanUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isi_laporan?: StringFieldUpdateOperationsInput | string
    tanggal_laporan?: StringFieldUpdateOperationsInput | string
    id_apoteker?: StringFieldUpdateOperationsInput | string
    id_pemilik?: IntFieldUpdateOperationsInput | number
  }

  export type PemilikCreateInput = {
    id: number
    Nama?: string | null
    Alamat?: string | null
    no_telp?: string | null
    laporan?: LaporanCreateNestedManyWithoutPemilikInput
  }

  export type PemilikUncheckedCreateInput = {
    id: number
    Nama?: string | null
    Alamat?: string | null
    no_telp?: string | null
    laporan?: LaporanUncheckedCreateNestedManyWithoutPemilikInput
  }

  export type PemilikUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Nama?: NullableStringFieldUpdateOperationsInput | string | null
    Alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    laporan?: LaporanUpdateManyWithoutPemilikNestedInput
  }

  export type PemilikUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    Nama?: NullableStringFieldUpdateOperationsInput | string | null
    Alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    laporan?: LaporanUncheckedUpdateManyWithoutPemilikNestedInput
  }

  export type PemilikCreateManyInput = {
    id: number
    Nama?: string | null
    Alamat?: string | null
    no_telp?: string | null
  }

  export type PemilikUpdateManyMutationInput = {
    id?: IntFieldUpdateOperationsInput | number
    Nama?: NullableStringFieldUpdateOperationsInput | string | null
    Alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PemilikUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    Nama?: NullableStringFieldUpdateOperationsInput | string | null
    Alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type Staff_gudangRelationFilter = {
    is?: Staff_gudangWhereInput
    isNot?: Staff_gudangWhereInput
  }

  export type SupplierRelationFilter = {
    is?: SupplierWhereInput
    isNot?: SupplierWhereInput
  }

  export type Det_pembelianListRelationFilter = {
    every?: Det_pembelianWhereInput
    some?: Det_pembelianWhereInput
    none?: Det_pembelianWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type Det_pembelianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ObatCountOrderByAggregateInput = {
    id?: SortOrder
    nama_obat?: SortOrder
    gambar?: SortOrder
    jenis_obat?: SortOrder
    tipe_obat?: SortOrder
    tanggal_expired?: SortOrder
    jumlah?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    stok_obat?: SortOrder
    kategori_obat?: SortOrder
    sub_kategori?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id_staff?: SortOrder
    id_supplier?: SortOrder
  }

  export type ObatAvgOrderByAggregateInput = {
    jumlah?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    stok_obat?: SortOrder
  }

  export type ObatMaxOrderByAggregateInput = {
    id?: SortOrder
    nama_obat?: SortOrder
    gambar?: SortOrder
    jenis_obat?: SortOrder
    tipe_obat?: SortOrder
    tanggal_expired?: SortOrder
    jumlah?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    stok_obat?: SortOrder
    kategori_obat?: SortOrder
    sub_kategori?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id_staff?: SortOrder
    id_supplier?: SortOrder
  }

  export type ObatMinOrderByAggregateInput = {
    id?: SortOrder
    nama_obat?: SortOrder
    gambar?: SortOrder
    jenis_obat?: SortOrder
    tipe_obat?: SortOrder
    tanggal_expired?: SortOrder
    jumlah?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    stok_obat?: SortOrder
    kategori_obat?: SortOrder
    sub_kategori?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    id_staff?: SortOrder
    id_supplier?: SortOrder
  }

  export type ObatSumOrderByAggregateInput = {
    jumlah?: SortOrder
    harga_beli?: SortOrder
    harga_jual?: SortOrder
    stok_obat?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PelangganRelationFilter = {
    is?: PelangganWhereInput
    isNot?: PelangganWhereInput
  }

  export type ApotekerRelationFilter = {
    is?: ApotekerWhereInput
    isNot?: ApotekerWhereInput
  }

  export type PembelianCountOrderByAggregateInput = {
    id?: SortOrder
    jumlah_jual?: SortOrder
    total_harga?: SortOrder
    tanggal_beli?: SortOrder
    jumlah_beli?: SortOrder
    id_pelanggan?: SortOrder
    id_apoteker?: SortOrder
  }

  export type PembelianAvgOrderByAggregateInput = {
    jumlah_jual?: SortOrder
    total_harga?: SortOrder
  }

  export type PembelianMaxOrderByAggregateInput = {
    id?: SortOrder
    jumlah_jual?: SortOrder
    total_harga?: SortOrder
    tanggal_beli?: SortOrder
    jumlah_beli?: SortOrder
    id_pelanggan?: SortOrder
    id_apoteker?: SortOrder
  }

  export type PembelianMinOrderByAggregateInput = {
    id?: SortOrder
    jumlah_jual?: SortOrder
    total_harga?: SortOrder
    tanggal_beli?: SortOrder
    jumlah_beli?: SortOrder
    id_pelanggan?: SortOrder
    id_apoteker?: SortOrder
  }

  export type PembelianSumOrderByAggregateInput = {
    jumlah_jual?: SortOrder
    total_harga?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type PembelianRelationFilter = {
    is?: PembelianWhereInput
    isNot?: PembelianWhereInput
  }

  export type ObatRelationFilter = {
    is?: ObatWhereInput
    isNot?: ObatWhereInput
  }

  export type Det_pembelianCountOrderByAggregateInput = {
    id?: SortOrder
    id_faktur?: SortOrder
    id_obat?: SortOrder
  }

  export type Det_pembelianMaxOrderByAggregateInput = {
    id?: SortOrder
    id_faktur?: SortOrder
    id_obat?: SortOrder
  }

  export type Det_pembelianMinOrderByAggregateInput = {
    id?: SortOrder
    id_faktur?: SortOrder
    id_obat?: SortOrder
  }

  export type ObatListRelationFilter = {
    every?: ObatWhereInput
    some?: ObatWhereInput
    none?: ObatWhereInput
  }

  export type ObatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type Staff_gudangCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type Staff_gudangMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type Staff_gudangMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type SupplierCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type SupplierMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type SupplierMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type LaporanListRelationFilter = {
    every?: LaporanWhereInput
    some?: LaporanWhereInput
    none?: LaporanWhereInput
  }

  export type PembelianListRelationFilter = {
    every?: PembelianWhereInput
    some?: PembelianWhereInput
    none?: PembelianWhereInput
  }

  export type LaporanOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PembelianOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ApotekerCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type ApotekerMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type ApotekerMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type PelangganCountOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type PelangganMaxOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type PelangganMinOrderByAggregateInput = {
    id?: SortOrder
    nama?: SortOrder
    alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type PemilikRelationFilter = {
    is?: PemilikWhereInput
    isNot?: PemilikWhereInput
  }

  export type LaporanCountOrderByAggregateInput = {
    id?: SortOrder
    isi_laporan?: SortOrder
    tanggal_laporan?: SortOrder
    id_apoteker?: SortOrder
    id_pemilik?: SortOrder
  }

  export type LaporanAvgOrderByAggregateInput = {
    id_pemilik?: SortOrder
  }

  export type LaporanMaxOrderByAggregateInput = {
    id?: SortOrder
    isi_laporan?: SortOrder
    tanggal_laporan?: SortOrder
    id_apoteker?: SortOrder
    id_pemilik?: SortOrder
  }

  export type LaporanMinOrderByAggregateInput = {
    id?: SortOrder
    isi_laporan?: SortOrder
    tanggal_laporan?: SortOrder
    id_apoteker?: SortOrder
    id_pemilik?: SortOrder
  }

  export type LaporanSumOrderByAggregateInput = {
    id_pemilik?: SortOrder
  }

  export type PemilikCountOrderByAggregateInput = {
    id?: SortOrder
    Nama?: SortOrder
    Alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type PemilikAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type PemilikMaxOrderByAggregateInput = {
    id?: SortOrder
    Nama?: SortOrder
    Alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type PemilikMinOrderByAggregateInput = {
    id?: SortOrder
    Nama?: SortOrder
    Alamat?: SortOrder
    no_telp?: SortOrder
  }

  export type PemilikSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type Staff_gudangCreateNestedOneWithoutObatInput = {
    create?: XOR<Staff_gudangCreateWithoutObatInput, Staff_gudangUncheckedCreateWithoutObatInput>
    connectOrCreate?: Staff_gudangCreateOrConnectWithoutObatInput
    connect?: Staff_gudangWhereUniqueInput
  }

  export type SupplierCreateNestedOneWithoutObatInput = {
    create?: XOR<SupplierCreateWithoutObatInput, SupplierUncheckedCreateWithoutObatInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutObatInput
    connect?: SupplierWhereUniqueInput
  }

  export type Det_pembelianCreateNestedManyWithoutObatInput = {
    create?: XOR<Det_pembelianCreateWithoutObatInput, Det_pembelianUncheckedCreateWithoutObatInput> | Det_pembelianCreateWithoutObatInput[] | Det_pembelianUncheckedCreateWithoutObatInput[]
    connectOrCreate?: Det_pembelianCreateOrConnectWithoutObatInput | Det_pembelianCreateOrConnectWithoutObatInput[]
    createMany?: Det_pembelianCreateManyObatInputEnvelope
    connect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
  }

  export type Det_pembelianUncheckedCreateNestedManyWithoutObatInput = {
    create?: XOR<Det_pembelianCreateWithoutObatInput, Det_pembelianUncheckedCreateWithoutObatInput> | Det_pembelianCreateWithoutObatInput[] | Det_pembelianUncheckedCreateWithoutObatInput[]
    connectOrCreate?: Det_pembelianCreateOrConnectWithoutObatInput | Det_pembelianCreateOrConnectWithoutObatInput[]
    createMany?: Det_pembelianCreateManyObatInputEnvelope
    connect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type Staff_gudangUpdateOneRequiredWithoutObatNestedInput = {
    create?: XOR<Staff_gudangCreateWithoutObatInput, Staff_gudangUncheckedCreateWithoutObatInput>
    connectOrCreate?: Staff_gudangCreateOrConnectWithoutObatInput
    upsert?: Staff_gudangUpsertWithoutObatInput
    connect?: Staff_gudangWhereUniqueInput
    update?: XOR<XOR<Staff_gudangUpdateToOneWithWhereWithoutObatInput, Staff_gudangUpdateWithoutObatInput>, Staff_gudangUncheckedUpdateWithoutObatInput>
  }

  export type SupplierUpdateOneRequiredWithoutObatNestedInput = {
    create?: XOR<SupplierCreateWithoutObatInput, SupplierUncheckedCreateWithoutObatInput>
    connectOrCreate?: SupplierCreateOrConnectWithoutObatInput
    upsert?: SupplierUpsertWithoutObatInput
    connect?: SupplierWhereUniqueInput
    update?: XOR<XOR<SupplierUpdateToOneWithWhereWithoutObatInput, SupplierUpdateWithoutObatInput>, SupplierUncheckedUpdateWithoutObatInput>
  }

  export type Det_pembelianUpdateManyWithoutObatNestedInput = {
    create?: XOR<Det_pembelianCreateWithoutObatInput, Det_pembelianUncheckedCreateWithoutObatInput> | Det_pembelianCreateWithoutObatInput[] | Det_pembelianUncheckedCreateWithoutObatInput[]
    connectOrCreate?: Det_pembelianCreateOrConnectWithoutObatInput | Det_pembelianCreateOrConnectWithoutObatInput[]
    upsert?: Det_pembelianUpsertWithWhereUniqueWithoutObatInput | Det_pembelianUpsertWithWhereUniqueWithoutObatInput[]
    createMany?: Det_pembelianCreateManyObatInputEnvelope
    set?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    disconnect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    delete?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    connect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    update?: Det_pembelianUpdateWithWhereUniqueWithoutObatInput | Det_pembelianUpdateWithWhereUniqueWithoutObatInput[]
    updateMany?: Det_pembelianUpdateManyWithWhereWithoutObatInput | Det_pembelianUpdateManyWithWhereWithoutObatInput[]
    deleteMany?: Det_pembelianScalarWhereInput | Det_pembelianScalarWhereInput[]
  }

  export type Det_pembelianUncheckedUpdateManyWithoutObatNestedInput = {
    create?: XOR<Det_pembelianCreateWithoutObatInput, Det_pembelianUncheckedCreateWithoutObatInput> | Det_pembelianCreateWithoutObatInput[] | Det_pembelianUncheckedCreateWithoutObatInput[]
    connectOrCreate?: Det_pembelianCreateOrConnectWithoutObatInput | Det_pembelianCreateOrConnectWithoutObatInput[]
    upsert?: Det_pembelianUpsertWithWhereUniqueWithoutObatInput | Det_pembelianUpsertWithWhereUniqueWithoutObatInput[]
    createMany?: Det_pembelianCreateManyObatInputEnvelope
    set?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    disconnect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    delete?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    connect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    update?: Det_pembelianUpdateWithWhereUniqueWithoutObatInput | Det_pembelianUpdateWithWhereUniqueWithoutObatInput[]
    updateMany?: Det_pembelianUpdateManyWithWhereWithoutObatInput | Det_pembelianUpdateManyWithWhereWithoutObatInput[]
    deleteMany?: Det_pembelianScalarWhereInput | Det_pembelianScalarWhereInput[]
  }

  export type PelangganCreateNestedOneWithoutPembelianInput = {
    create?: XOR<PelangganCreateWithoutPembelianInput, PelangganUncheckedCreateWithoutPembelianInput>
    connectOrCreate?: PelangganCreateOrConnectWithoutPembelianInput
    connect?: PelangganWhereUniqueInput
  }

  export type ApotekerCreateNestedOneWithoutPembelianInput = {
    create?: XOR<ApotekerCreateWithoutPembelianInput, ApotekerUncheckedCreateWithoutPembelianInput>
    connectOrCreate?: ApotekerCreateOrConnectWithoutPembelianInput
    connect?: ApotekerWhereUniqueInput
  }

  export type Det_pembelianCreateNestedManyWithoutPembelianInput = {
    create?: XOR<Det_pembelianCreateWithoutPembelianInput, Det_pembelianUncheckedCreateWithoutPembelianInput> | Det_pembelianCreateWithoutPembelianInput[] | Det_pembelianUncheckedCreateWithoutPembelianInput[]
    connectOrCreate?: Det_pembelianCreateOrConnectWithoutPembelianInput | Det_pembelianCreateOrConnectWithoutPembelianInput[]
    createMany?: Det_pembelianCreateManyPembelianInputEnvelope
    connect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
  }

  export type Det_pembelianUncheckedCreateNestedManyWithoutPembelianInput = {
    create?: XOR<Det_pembelianCreateWithoutPembelianInput, Det_pembelianUncheckedCreateWithoutPembelianInput> | Det_pembelianCreateWithoutPembelianInput[] | Det_pembelianUncheckedCreateWithoutPembelianInput[]
    connectOrCreate?: Det_pembelianCreateOrConnectWithoutPembelianInput | Det_pembelianCreateOrConnectWithoutPembelianInput[]
    createMany?: Det_pembelianCreateManyPembelianInputEnvelope
    connect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type PelangganUpdateOneRequiredWithoutPembelianNestedInput = {
    create?: XOR<PelangganCreateWithoutPembelianInput, PelangganUncheckedCreateWithoutPembelianInput>
    connectOrCreate?: PelangganCreateOrConnectWithoutPembelianInput
    upsert?: PelangganUpsertWithoutPembelianInput
    connect?: PelangganWhereUniqueInput
    update?: XOR<XOR<PelangganUpdateToOneWithWhereWithoutPembelianInput, PelangganUpdateWithoutPembelianInput>, PelangganUncheckedUpdateWithoutPembelianInput>
  }

  export type ApotekerUpdateOneRequiredWithoutPembelianNestedInput = {
    create?: XOR<ApotekerCreateWithoutPembelianInput, ApotekerUncheckedCreateWithoutPembelianInput>
    connectOrCreate?: ApotekerCreateOrConnectWithoutPembelianInput
    upsert?: ApotekerUpsertWithoutPembelianInput
    connect?: ApotekerWhereUniqueInput
    update?: XOR<XOR<ApotekerUpdateToOneWithWhereWithoutPembelianInput, ApotekerUpdateWithoutPembelianInput>, ApotekerUncheckedUpdateWithoutPembelianInput>
  }

  export type Det_pembelianUpdateManyWithoutPembelianNestedInput = {
    create?: XOR<Det_pembelianCreateWithoutPembelianInput, Det_pembelianUncheckedCreateWithoutPembelianInput> | Det_pembelianCreateWithoutPembelianInput[] | Det_pembelianUncheckedCreateWithoutPembelianInput[]
    connectOrCreate?: Det_pembelianCreateOrConnectWithoutPembelianInput | Det_pembelianCreateOrConnectWithoutPembelianInput[]
    upsert?: Det_pembelianUpsertWithWhereUniqueWithoutPembelianInput | Det_pembelianUpsertWithWhereUniqueWithoutPembelianInput[]
    createMany?: Det_pembelianCreateManyPembelianInputEnvelope
    set?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    disconnect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    delete?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    connect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    update?: Det_pembelianUpdateWithWhereUniqueWithoutPembelianInput | Det_pembelianUpdateWithWhereUniqueWithoutPembelianInput[]
    updateMany?: Det_pembelianUpdateManyWithWhereWithoutPembelianInput | Det_pembelianUpdateManyWithWhereWithoutPembelianInput[]
    deleteMany?: Det_pembelianScalarWhereInput | Det_pembelianScalarWhereInput[]
  }

  export type Det_pembelianUncheckedUpdateManyWithoutPembelianNestedInput = {
    create?: XOR<Det_pembelianCreateWithoutPembelianInput, Det_pembelianUncheckedCreateWithoutPembelianInput> | Det_pembelianCreateWithoutPembelianInput[] | Det_pembelianUncheckedCreateWithoutPembelianInput[]
    connectOrCreate?: Det_pembelianCreateOrConnectWithoutPembelianInput | Det_pembelianCreateOrConnectWithoutPembelianInput[]
    upsert?: Det_pembelianUpsertWithWhereUniqueWithoutPembelianInput | Det_pembelianUpsertWithWhereUniqueWithoutPembelianInput[]
    createMany?: Det_pembelianCreateManyPembelianInputEnvelope
    set?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    disconnect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    delete?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    connect?: Det_pembelianWhereUniqueInput | Det_pembelianWhereUniqueInput[]
    update?: Det_pembelianUpdateWithWhereUniqueWithoutPembelianInput | Det_pembelianUpdateWithWhereUniqueWithoutPembelianInput[]
    updateMany?: Det_pembelianUpdateManyWithWhereWithoutPembelianInput | Det_pembelianUpdateManyWithWhereWithoutPembelianInput[]
    deleteMany?: Det_pembelianScalarWhereInput | Det_pembelianScalarWhereInput[]
  }

  export type PembelianCreateNestedOneWithoutDet_pembelianInput = {
    create?: XOR<PembelianCreateWithoutDet_pembelianInput, PembelianUncheckedCreateWithoutDet_pembelianInput>
    connectOrCreate?: PembelianCreateOrConnectWithoutDet_pembelianInput
    connect?: PembelianWhereUniqueInput
  }

  export type ObatCreateNestedOneWithoutDet_pembelianInput = {
    create?: XOR<ObatCreateWithoutDet_pembelianInput, ObatUncheckedCreateWithoutDet_pembelianInput>
    connectOrCreate?: ObatCreateOrConnectWithoutDet_pembelianInput
    connect?: ObatWhereUniqueInput
  }

  export type PembelianUpdateOneRequiredWithoutDet_pembelianNestedInput = {
    create?: XOR<PembelianCreateWithoutDet_pembelianInput, PembelianUncheckedCreateWithoutDet_pembelianInput>
    connectOrCreate?: PembelianCreateOrConnectWithoutDet_pembelianInput
    upsert?: PembelianUpsertWithoutDet_pembelianInput
    connect?: PembelianWhereUniqueInput
    update?: XOR<XOR<PembelianUpdateToOneWithWhereWithoutDet_pembelianInput, PembelianUpdateWithoutDet_pembelianInput>, PembelianUncheckedUpdateWithoutDet_pembelianInput>
  }

  export type ObatUpdateOneRequiredWithoutDet_pembelianNestedInput = {
    create?: XOR<ObatCreateWithoutDet_pembelianInput, ObatUncheckedCreateWithoutDet_pembelianInput>
    connectOrCreate?: ObatCreateOrConnectWithoutDet_pembelianInput
    upsert?: ObatUpsertWithoutDet_pembelianInput
    connect?: ObatWhereUniqueInput
    update?: XOR<XOR<ObatUpdateToOneWithWhereWithoutDet_pembelianInput, ObatUpdateWithoutDet_pembelianInput>, ObatUncheckedUpdateWithoutDet_pembelianInput>
  }

  export type ObatCreateNestedManyWithoutStaffInput = {
    create?: XOR<ObatCreateWithoutStaffInput, ObatUncheckedCreateWithoutStaffInput> | ObatCreateWithoutStaffInput[] | ObatUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ObatCreateOrConnectWithoutStaffInput | ObatCreateOrConnectWithoutStaffInput[]
    createMany?: ObatCreateManyStaffInputEnvelope
    connect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
  }

  export type ObatUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ObatCreateWithoutStaffInput, ObatUncheckedCreateWithoutStaffInput> | ObatCreateWithoutStaffInput[] | ObatUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ObatCreateOrConnectWithoutStaffInput | ObatCreateOrConnectWithoutStaffInput[]
    createMany?: ObatCreateManyStaffInputEnvelope
    connect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
  }

  export type ObatUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ObatCreateWithoutStaffInput, ObatUncheckedCreateWithoutStaffInput> | ObatCreateWithoutStaffInput[] | ObatUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ObatCreateOrConnectWithoutStaffInput | ObatCreateOrConnectWithoutStaffInput[]
    upsert?: ObatUpsertWithWhereUniqueWithoutStaffInput | ObatUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ObatCreateManyStaffInputEnvelope
    set?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    disconnect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    delete?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    connect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    update?: ObatUpdateWithWhereUniqueWithoutStaffInput | ObatUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ObatUpdateManyWithWhereWithoutStaffInput | ObatUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ObatScalarWhereInput | ObatScalarWhereInput[]
  }

  export type ObatUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ObatCreateWithoutStaffInput, ObatUncheckedCreateWithoutStaffInput> | ObatCreateWithoutStaffInput[] | ObatUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ObatCreateOrConnectWithoutStaffInput | ObatCreateOrConnectWithoutStaffInput[]
    upsert?: ObatUpsertWithWhereUniqueWithoutStaffInput | ObatUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ObatCreateManyStaffInputEnvelope
    set?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    disconnect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    delete?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    connect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    update?: ObatUpdateWithWhereUniqueWithoutStaffInput | ObatUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ObatUpdateManyWithWhereWithoutStaffInput | ObatUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ObatScalarWhereInput | ObatScalarWhereInput[]
  }

  export type ObatCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ObatCreateWithoutSupplierInput, ObatUncheckedCreateWithoutSupplierInput> | ObatCreateWithoutSupplierInput[] | ObatUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ObatCreateOrConnectWithoutSupplierInput | ObatCreateOrConnectWithoutSupplierInput[]
    createMany?: ObatCreateManySupplierInputEnvelope
    connect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
  }

  export type ObatUncheckedCreateNestedManyWithoutSupplierInput = {
    create?: XOR<ObatCreateWithoutSupplierInput, ObatUncheckedCreateWithoutSupplierInput> | ObatCreateWithoutSupplierInput[] | ObatUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ObatCreateOrConnectWithoutSupplierInput | ObatCreateOrConnectWithoutSupplierInput[]
    createMany?: ObatCreateManySupplierInputEnvelope
    connect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
  }

  export type ObatUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ObatCreateWithoutSupplierInput, ObatUncheckedCreateWithoutSupplierInput> | ObatCreateWithoutSupplierInput[] | ObatUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ObatCreateOrConnectWithoutSupplierInput | ObatCreateOrConnectWithoutSupplierInput[]
    upsert?: ObatUpsertWithWhereUniqueWithoutSupplierInput | ObatUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ObatCreateManySupplierInputEnvelope
    set?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    disconnect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    delete?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    connect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    update?: ObatUpdateWithWhereUniqueWithoutSupplierInput | ObatUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ObatUpdateManyWithWhereWithoutSupplierInput | ObatUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ObatScalarWhereInput | ObatScalarWhereInput[]
  }

  export type ObatUncheckedUpdateManyWithoutSupplierNestedInput = {
    create?: XOR<ObatCreateWithoutSupplierInput, ObatUncheckedCreateWithoutSupplierInput> | ObatCreateWithoutSupplierInput[] | ObatUncheckedCreateWithoutSupplierInput[]
    connectOrCreate?: ObatCreateOrConnectWithoutSupplierInput | ObatCreateOrConnectWithoutSupplierInput[]
    upsert?: ObatUpsertWithWhereUniqueWithoutSupplierInput | ObatUpsertWithWhereUniqueWithoutSupplierInput[]
    createMany?: ObatCreateManySupplierInputEnvelope
    set?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    disconnect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    delete?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    connect?: ObatWhereUniqueInput | ObatWhereUniqueInput[]
    update?: ObatUpdateWithWhereUniqueWithoutSupplierInput | ObatUpdateWithWhereUniqueWithoutSupplierInput[]
    updateMany?: ObatUpdateManyWithWhereWithoutSupplierInput | ObatUpdateManyWithWhereWithoutSupplierInput[]
    deleteMany?: ObatScalarWhereInput | ObatScalarWhereInput[]
  }

  export type LaporanCreateNestedManyWithoutApotekerInput = {
    create?: XOR<LaporanCreateWithoutApotekerInput, LaporanUncheckedCreateWithoutApotekerInput> | LaporanCreateWithoutApotekerInput[] | LaporanUncheckedCreateWithoutApotekerInput[]
    connectOrCreate?: LaporanCreateOrConnectWithoutApotekerInput | LaporanCreateOrConnectWithoutApotekerInput[]
    createMany?: LaporanCreateManyApotekerInputEnvelope
    connect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
  }

  export type PembelianCreateNestedManyWithoutApotekerInput = {
    create?: XOR<PembelianCreateWithoutApotekerInput, PembelianUncheckedCreateWithoutApotekerInput> | PembelianCreateWithoutApotekerInput[] | PembelianUncheckedCreateWithoutApotekerInput[]
    connectOrCreate?: PembelianCreateOrConnectWithoutApotekerInput | PembelianCreateOrConnectWithoutApotekerInput[]
    createMany?: PembelianCreateManyApotekerInputEnvelope
    connect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
  }

  export type LaporanUncheckedCreateNestedManyWithoutApotekerInput = {
    create?: XOR<LaporanCreateWithoutApotekerInput, LaporanUncheckedCreateWithoutApotekerInput> | LaporanCreateWithoutApotekerInput[] | LaporanUncheckedCreateWithoutApotekerInput[]
    connectOrCreate?: LaporanCreateOrConnectWithoutApotekerInput | LaporanCreateOrConnectWithoutApotekerInput[]
    createMany?: LaporanCreateManyApotekerInputEnvelope
    connect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
  }

  export type PembelianUncheckedCreateNestedManyWithoutApotekerInput = {
    create?: XOR<PembelianCreateWithoutApotekerInput, PembelianUncheckedCreateWithoutApotekerInput> | PembelianCreateWithoutApotekerInput[] | PembelianUncheckedCreateWithoutApotekerInput[]
    connectOrCreate?: PembelianCreateOrConnectWithoutApotekerInput | PembelianCreateOrConnectWithoutApotekerInput[]
    createMany?: PembelianCreateManyApotekerInputEnvelope
    connect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
  }

  export type LaporanUpdateManyWithoutApotekerNestedInput = {
    create?: XOR<LaporanCreateWithoutApotekerInput, LaporanUncheckedCreateWithoutApotekerInput> | LaporanCreateWithoutApotekerInput[] | LaporanUncheckedCreateWithoutApotekerInput[]
    connectOrCreate?: LaporanCreateOrConnectWithoutApotekerInput | LaporanCreateOrConnectWithoutApotekerInput[]
    upsert?: LaporanUpsertWithWhereUniqueWithoutApotekerInput | LaporanUpsertWithWhereUniqueWithoutApotekerInput[]
    createMany?: LaporanCreateManyApotekerInputEnvelope
    set?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    disconnect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    delete?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    connect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    update?: LaporanUpdateWithWhereUniqueWithoutApotekerInput | LaporanUpdateWithWhereUniqueWithoutApotekerInput[]
    updateMany?: LaporanUpdateManyWithWhereWithoutApotekerInput | LaporanUpdateManyWithWhereWithoutApotekerInput[]
    deleteMany?: LaporanScalarWhereInput | LaporanScalarWhereInput[]
  }

  export type PembelianUpdateManyWithoutApotekerNestedInput = {
    create?: XOR<PembelianCreateWithoutApotekerInput, PembelianUncheckedCreateWithoutApotekerInput> | PembelianCreateWithoutApotekerInput[] | PembelianUncheckedCreateWithoutApotekerInput[]
    connectOrCreate?: PembelianCreateOrConnectWithoutApotekerInput | PembelianCreateOrConnectWithoutApotekerInput[]
    upsert?: PembelianUpsertWithWhereUniqueWithoutApotekerInput | PembelianUpsertWithWhereUniqueWithoutApotekerInput[]
    createMany?: PembelianCreateManyApotekerInputEnvelope
    set?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    disconnect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    delete?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    connect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    update?: PembelianUpdateWithWhereUniqueWithoutApotekerInput | PembelianUpdateWithWhereUniqueWithoutApotekerInput[]
    updateMany?: PembelianUpdateManyWithWhereWithoutApotekerInput | PembelianUpdateManyWithWhereWithoutApotekerInput[]
    deleteMany?: PembelianScalarWhereInput | PembelianScalarWhereInput[]
  }

  export type LaporanUncheckedUpdateManyWithoutApotekerNestedInput = {
    create?: XOR<LaporanCreateWithoutApotekerInput, LaporanUncheckedCreateWithoutApotekerInput> | LaporanCreateWithoutApotekerInput[] | LaporanUncheckedCreateWithoutApotekerInput[]
    connectOrCreate?: LaporanCreateOrConnectWithoutApotekerInput | LaporanCreateOrConnectWithoutApotekerInput[]
    upsert?: LaporanUpsertWithWhereUniqueWithoutApotekerInput | LaporanUpsertWithWhereUniqueWithoutApotekerInput[]
    createMany?: LaporanCreateManyApotekerInputEnvelope
    set?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    disconnect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    delete?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    connect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    update?: LaporanUpdateWithWhereUniqueWithoutApotekerInput | LaporanUpdateWithWhereUniqueWithoutApotekerInput[]
    updateMany?: LaporanUpdateManyWithWhereWithoutApotekerInput | LaporanUpdateManyWithWhereWithoutApotekerInput[]
    deleteMany?: LaporanScalarWhereInput | LaporanScalarWhereInput[]
  }

  export type PembelianUncheckedUpdateManyWithoutApotekerNestedInput = {
    create?: XOR<PembelianCreateWithoutApotekerInput, PembelianUncheckedCreateWithoutApotekerInput> | PembelianCreateWithoutApotekerInput[] | PembelianUncheckedCreateWithoutApotekerInput[]
    connectOrCreate?: PembelianCreateOrConnectWithoutApotekerInput | PembelianCreateOrConnectWithoutApotekerInput[]
    upsert?: PembelianUpsertWithWhereUniqueWithoutApotekerInput | PembelianUpsertWithWhereUniqueWithoutApotekerInput[]
    createMany?: PembelianCreateManyApotekerInputEnvelope
    set?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    disconnect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    delete?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    connect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    update?: PembelianUpdateWithWhereUniqueWithoutApotekerInput | PembelianUpdateWithWhereUniqueWithoutApotekerInput[]
    updateMany?: PembelianUpdateManyWithWhereWithoutApotekerInput | PembelianUpdateManyWithWhereWithoutApotekerInput[]
    deleteMany?: PembelianScalarWhereInput | PembelianScalarWhereInput[]
  }

  export type PembelianCreateNestedManyWithoutPelangganInput = {
    create?: XOR<PembelianCreateWithoutPelangganInput, PembelianUncheckedCreateWithoutPelangganInput> | PembelianCreateWithoutPelangganInput[] | PembelianUncheckedCreateWithoutPelangganInput[]
    connectOrCreate?: PembelianCreateOrConnectWithoutPelangganInput | PembelianCreateOrConnectWithoutPelangganInput[]
    createMany?: PembelianCreateManyPelangganInputEnvelope
    connect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
  }

  export type PembelianUncheckedCreateNestedManyWithoutPelangganInput = {
    create?: XOR<PembelianCreateWithoutPelangganInput, PembelianUncheckedCreateWithoutPelangganInput> | PembelianCreateWithoutPelangganInput[] | PembelianUncheckedCreateWithoutPelangganInput[]
    connectOrCreate?: PembelianCreateOrConnectWithoutPelangganInput | PembelianCreateOrConnectWithoutPelangganInput[]
    createMany?: PembelianCreateManyPelangganInputEnvelope
    connect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
  }

  export type PembelianUpdateManyWithoutPelangganNestedInput = {
    create?: XOR<PembelianCreateWithoutPelangganInput, PembelianUncheckedCreateWithoutPelangganInput> | PembelianCreateWithoutPelangganInput[] | PembelianUncheckedCreateWithoutPelangganInput[]
    connectOrCreate?: PembelianCreateOrConnectWithoutPelangganInput | PembelianCreateOrConnectWithoutPelangganInput[]
    upsert?: PembelianUpsertWithWhereUniqueWithoutPelangganInput | PembelianUpsertWithWhereUniqueWithoutPelangganInput[]
    createMany?: PembelianCreateManyPelangganInputEnvelope
    set?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    disconnect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    delete?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    connect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    update?: PembelianUpdateWithWhereUniqueWithoutPelangganInput | PembelianUpdateWithWhereUniqueWithoutPelangganInput[]
    updateMany?: PembelianUpdateManyWithWhereWithoutPelangganInput | PembelianUpdateManyWithWhereWithoutPelangganInput[]
    deleteMany?: PembelianScalarWhereInput | PembelianScalarWhereInput[]
  }

  export type PembelianUncheckedUpdateManyWithoutPelangganNestedInput = {
    create?: XOR<PembelianCreateWithoutPelangganInput, PembelianUncheckedCreateWithoutPelangganInput> | PembelianCreateWithoutPelangganInput[] | PembelianUncheckedCreateWithoutPelangganInput[]
    connectOrCreate?: PembelianCreateOrConnectWithoutPelangganInput | PembelianCreateOrConnectWithoutPelangganInput[]
    upsert?: PembelianUpsertWithWhereUniqueWithoutPelangganInput | PembelianUpsertWithWhereUniqueWithoutPelangganInput[]
    createMany?: PembelianCreateManyPelangganInputEnvelope
    set?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    disconnect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    delete?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    connect?: PembelianWhereUniqueInput | PembelianWhereUniqueInput[]
    update?: PembelianUpdateWithWhereUniqueWithoutPelangganInput | PembelianUpdateWithWhereUniqueWithoutPelangganInput[]
    updateMany?: PembelianUpdateManyWithWhereWithoutPelangganInput | PembelianUpdateManyWithWhereWithoutPelangganInput[]
    deleteMany?: PembelianScalarWhereInput | PembelianScalarWhereInput[]
  }

  export type ApotekerCreateNestedOneWithoutLaporanInput = {
    create?: XOR<ApotekerCreateWithoutLaporanInput, ApotekerUncheckedCreateWithoutLaporanInput>
    connectOrCreate?: ApotekerCreateOrConnectWithoutLaporanInput
    connect?: ApotekerWhereUniqueInput
  }

  export type PemilikCreateNestedOneWithoutLaporanInput = {
    create?: XOR<PemilikCreateWithoutLaporanInput, PemilikUncheckedCreateWithoutLaporanInput>
    connectOrCreate?: PemilikCreateOrConnectWithoutLaporanInput
    connect?: PemilikWhereUniqueInput
  }

  export type ApotekerUpdateOneRequiredWithoutLaporanNestedInput = {
    create?: XOR<ApotekerCreateWithoutLaporanInput, ApotekerUncheckedCreateWithoutLaporanInput>
    connectOrCreate?: ApotekerCreateOrConnectWithoutLaporanInput
    upsert?: ApotekerUpsertWithoutLaporanInput
    connect?: ApotekerWhereUniqueInput
    update?: XOR<XOR<ApotekerUpdateToOneWithWhereWithoutLaporanInput, ApotekerUpdateWithoutLaporanInput>, ApotekerUncheckedUpdateWithoutLaporanInput>
  }

  export type PemilikUpdateOneRequiredWithoutLaporanNestedInput = {
    create?: XOR<PemilikCreateWithoutLaporanInput, PemilikUncheckedCreateWithoutLaporanInput>
    connectOrCreate?: PemilikCreateOrConnectWithoutLaporanInput
    upsert?: PemilikUpsertWithoutLaporanInput
    connect?: PemilikWhereUniqueInput
    update?: XOR<XOR<PemilikUpdateToOneWithWhereWithoutLaporanInput, PemilikUpdateWithoutLaporanInput>, PemilikUncheckedUpdateWithoutLaporanInput>
  }

  export type LaporanCreateNestedManyWithoutPemilikInput = {
    create?: XOR<LaporanCreateWithoutPemilikInput, LaporanUncheckedCreateWithoutPemilikInput> | LaporanCreateWithoutPemilikInput[] | LaporanUncheckedCreateWithoutPemilikInput[]
    connectOrCreate?: LaporanCreateOrConnectWithoutPemilikInput | LaporanCreateOrConnectWithoutPemilikInput[]
    createMany?: LaporanCreateManyPemilikInputEnvelope
    connect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
  }

  export type LaporanUncheckedCreateNestedManyWithoutPemilikInput = {
    create?: XOR<LaporanCreateWithoutPemilikInput, LaporanUncheckedCreateWithoutPemilikInput> | LaporanCreateWithoutPemilikInput[] | LaporanUncheckedCreateWithoutPemilikInput[]
    connectOrCreate?: LaporanCreateOrConnectWithoutPemilikInput | LaporanCreateOrConnectWithoutPemilikInput[]
    createMany?: LaporanCreateManyPemilikInputEnvelope
    connect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
  }

  export type LaporanUpdateManyWithoutPemilikNestedInput = {
    create?: XOR<LaporanCreateWithoutPemilikInput, LaporanUncheckedCreateWithoutPemilikInput> | LaporanCreateWithoutPemilikInput[] | LaporanUncheckedCreateWithoutPemilikInput[]
    connectOrCreate?: LaporanCreateOrConnectWithoutPemilikInput | LaporanCreateOrConnectWithoutPemilikInput[]
    upsert?: LaporanUpsertWithWhereUniqueWithoutPemilikInput | LaporanUpsertWithWhereUniqueWithoutPemilikInput[]
    createMany?: LaporanCreateManyPemilikInputEnvelope
    set?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    disconnect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    delete?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    connect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    update?: LaporanUpdateWithWhereUniqueWithoutPemilikInput | LaporanUpdateWithWhereUniqueWithoutPemilikInput[]
    updateMany?: LaporanUpdateManyWithWhereWithoutPemilikInput | LaporanUpdateManyWithWhereWithoutPemilikInput[]
    deleteMany?: LaporanScalarWhereInput | LaporanScalarWhereInput[]
  }

  export type LaporanUncheckedUpdateManyWithoutPemilikNestedInput = {
    create?: XOR<LaporanCreateWithoutPemilikInput, LaporanUncheckedCreateWithoutPemilikInput> | LaporanCreateWithoutPemilikInput[] | LaporanUncheckedCreateWithoutPemilikInput[]
    connectOrCreate?: LaporanCreateOrConnectWithoutPemilikInput | LaporanCreateOrConnectWithoutPemilikInput[]
    upsert?: LaporanUpsertWithWhereUniqueWithoutPemilikInput | LaporanUpsertWithWhereUniqueWithoutPemilikInput[]
    createMany?: LaporanCreateManyPemilikInputEnvelope
    set?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    disconnect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    delete?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    connect?: LaporanWhereUniqueInput | LaporanWhereUniqueInput[]
    update?: LaporanUpdateWithWhereUniqueWithoutPemilikInput | LaporanUpdateWithWhereUniqueWithoutPemilikInput[]
    updateMany?: LaporanUpdateManyWithWhereWithoutPemilikInput | LaporanUpdateManyWithWhereWithoutPemilikInput[]
    deleteMany?: LaporanScalarWhereInput | LaporanScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Staff_gudangCreateWithoutObatInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
  }

  export type Staff_gudangUncheckedCreateWithoutObatInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
  }

  export type Staff_gudangCreateOrConnectWithoutObatInput = {
    where: Staff_gudangWhereUniqueInput
    create: XOR<Staff_gudangCreateWithoutObatInput, Staff_gudangUncheckedCreateWithoutObatInput>
  }

  export type SupplierCreateWithoutObatInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
  }

  export type SupplierUncheckedCreateWithoutObatInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
  }

  export type SupplierCreateOrConnectWithoutObatInput = {
    where: SupplierWhereUniqueInput
    create: XOR<SupplierCreateWithoutObatInput, SupplierUncheckedCreateWithoutObatInput>
  }

  export type Det_pembelianCreateWithoutObatInput = {
    id: string
    pembelian: PembelianCreateNestedOneWithoutDet_pembelianInput
  }

  export type Det_pembelianUncheckedCreateWithoutObatInput = {
    id: string
    id_faktur: string
  }

  export type Det_pembelianCreateOrConnectWithoutObatInput = {
    where: Det_pembelianWhereUniqueInput
    create: XOR<Det_pembelianCreateWithoutObatInput, Det_pembelianUncheckedCreateWithoutObatInput>
  }

  export type Det_pembelianCreateManyObatInputEnvelope = {
    data: Det_pembelianCreateManyObatInput | Det_pembelianCreateManyObatInput[]
    skipDuplicates?: boolean
  }

  export type Staff_gudangUpsertWithoutObatInput = {
    update: XOR<Staff_gudangUpdateWithoutObatInput, Staff_gudangUncheckedUpdateWithoutObatInput>
    create: XOR<Staff_gudangCreateWithoutObatInput, Staff_gudangUncheckedCreateWithoutObatInput>
    where?: Staff_gudangWhereInput
  }

  export type Staff_gudangUpdateToOneWithWhereWithoutObatInput = {
    where?: Staff_gudangWhereInput
    data: XOR<Staff_gudangUpdateWithoutObatInput, Staff_gudangUncheckedUpdateWithoutObatInput>
  }

  export type Staff_gudangUpdateWithoutObatInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Staff_gudangUncheckedUpdateWithoutObatInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierUpsertWithoutObatInput = {
    update: XOR<SupplierUpdateWithoutObatInput, SupplierUncheckedUpdateWithoutObatInput>
    create: XOR<SupplierCreateWithoutObatInput, SupplierUncheckedCreateWithoutObatInput>
    where?: SupplierWhereInput
  }

  export type SupplierUpdateToOneWithWhereWithoutObatInput = {
    where?: SupplierWhereInput
    data: XOR<SupplierUpdateWithoutObatInput, SupplierUncheckedUpdateWithoutObatInput>
  }

  export type SupplierUpdateWithoutObatInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SupplierUncheckedUpdateWithoutObatInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type Det_pembelianUpsertWithWhereUniqueWithoutObatInput = {
    where: Det_pembelianWhereUniqueInput
    update: XOR<Det_pembelianUpdateWithoutObatInput, Det_pembelianUncheckedUpdateWithoutObatInput>
    create: XOR<Det_pembelianCreateWithoutObatInput, Det_pembelianUncheckedCreateWithoutObatInput>
  }

  export type Det_pembelianUpdateWithWhereUniqueWithoutObatInput = {
    where: Det_pembelianWhereUniqueInput
    data: XOR<Det_pembelianUpdateWithoutObatInput, Det_pembelianUncheckedUpdateWithoutObatInput>
  }

  export type Det_pembelianUpdateManyWithWhereWithoutObatInput = {
    where: Det_pembelianScalarWhereInput
    data: XOR<Det_pembelianUpdateManyMutationInput, Det_pembelianUncheckedUpdateManyWithoutObatInput>
  }

  export type Det_pembelianScalarWhereInput = {
    AND?: Det_pembelianScalarWhereInput | Det_pembelianScalarWhereInput[]
    OR?: Det_pembelianScalarWhereInput[]
    NOT?: Det_pembelianScalarWhereInput | Det_pembelianScalarWhereInput[]
    id?: StringFilter<"Det_pembelian"> | string
    id_faktur?: StringFilter<"Det_pembelian"> | string
    id_obat?: StringFilter<"Det_pembelian"> | string
  }

  export type PelangganCreateWithoutPembelianInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
  }

  export type PelangganUncheckedCreateWithoutPembelianInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
  }

  export type PelangganCreateOrConnectWithoutPembelianInput = {
    where: PelangganWhereUniqueInput
    create: XOR<PelangganCreateWithoutPembelianInput, PelangganUncheckedCreateWithoutPembelianInput>
  }

  export type ApotekerCreateWithoutPembelianInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    laporan?: LaporanCreateNestedManyWithoutApotekerInput
  }

  export type ApotekerUncheckedCreateWithoutPembelianInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    laporan?: LaporanUncheckedCreateNestedManyWithoutApotekerInput
  }

  export type ApotekerCreateOrConnectWithoutPembelianInput = {
    where: ApotekerWhereUniqueInput
    create: XOR<ApotekerCreateWithoutPembelianInput, ApotekerUncheckedCreateWithoutPembelianInput>
  }

  export type Det_pembelianCreateWithoutPembelianInput = {
    id: string
    obat: ObatCreateNestedOneWithoutDet_pembelianInput
  }

  export type Det_pembelianUncheckedCreateWithoutPembelianInput = {
    id: string
    id_obat: string
  }

  export type Det_pembelianCreateOrConnectWithoutPembelianInput = {
    where: Det_pembelianWhereUniqueInput
    create: XOR<Det_pembelianCreateWithoutPembelianInput, Det_pembelianUncheckedCreateWithoutPembelianInput>
  }

  export type Det_pembelianCreateManyPembelianInputEnvelope = {
    data: Det_pembelianCreateManyPembelianInput | Det_pembelianCreateManyPembelianInput[]
    skipDuplicates?: boolean
  }

  export type PelangganUpsertWithoutPembelianInput = {
    update: XOR<PelangganUpdateWithoutPembelianInput, PelangganUncheckedUpdateWithoutPembelianInput>
    create: XOR<PelangganCreateWithoutPembelianInput, PelangganUncheckedCreateWithoutPembelianInput>
    where?: PelangganWhereInput
  }

  export type PelangganUpdateToOneWithWhereWithoutPembelianInput = {
    where?: PelangganWhereInput
    data: XOR<PelangganUpdateWithoutPembelianInput, PelangganUncheckedUpdateWithoutPembelianInput>
  }

  export type PelangganUpdateWithoutPembelianInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PelangganUncheckedUpdateWithoutPembelianInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ApotekerUpsertWithoutPembelianInput = {
    update: XOR<ApotekerUpdateWithoutPembelianInput, ApotekerUncheckedUpdateWithoutPembelianInput>
    create: XOR<ApotekerCreateWithoutPembelianInput, ApotekerUncheckedCreateWithoutPembelianInput>
    where?: ApotekerWhereInput
  }

  export type ApotekerUpdateToOneWithWhereWithoutPembelianInput = {
    where?: ApotekerWhereInput
    data: XOR<ApotekerUpdateWithoutPembelianInput, ApotekerUncheckedUpdateWithoutPembelianInput>
  }

  export type ApotekerUpdateWithoutPembelianInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    laporan?: LaporanUpdateManyWithoutApotekerNestedInput
  }

  export type ApotekerUncheckedUpdateWithoutPembelianInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    laporan?: LaporanUncheckedUpdateManyWithoutApotekerNestedInput
  }

  export type Det_pembelianUpsertWithWhereUniqueWithoutPembelianInput = {
    where: Det_pembelianWhereUniqueInput
    update: XOR<Det_pembelianUpdateWithoutPembelianInput, Det_pembelianUncheckedUpdateWithoutPembelianInput>
    create: XOR<Det_pembelianCreateWithoutPembelianInput, Det_pembelianUncheckedCreateWithoutPembelianInput>
  }

  export type Det_pembelianUpdateWithWhereUniqueWithoutPembelianInput = {
    where: Det_pembelianWhereUniqueInput
    data: XOR<Det_pembelianUpdateWithoutPembelianInput, Det_pembelianUncheckedUpdateWithoutPembelianInput>
  }

  export type Det_pembelianUpdateManyWithWhereWithoutPembelianInput = {
    where: Det_pembelianScalarWhereInput
    data: XOR<Det_pembelianUpdateManyMutationInput, Det_pembelianUncheckedUpdateManyWithoutPembelianInput>
  }

  export type PembelianCreateWithoutDet_pembelianInput = {
    id: string
    jumlah_jual?: number | null
    total_harga: number
    tanggal_beli?: Date | string | null
    jumlah_beli?: string | null
    pelanggan: PelangganCreateNestedOneWithoutPembelianInput
    apoteker: ApotekerCreateNestedOneWithoutPembelianInput
  }

  export type PembelianUncheckedCreateWithoutDet_pembelianInput = {
    id: string
    jumlah_jual?: number | null
    total_harga: number
    tanggal_beli?: Date | string | null
    jumlah_beli?: string | null
    id_pelanggan: string
    id_apoteker: string
  }

  export type PembelianCreateOrConnectWithoutDet_pembelianInput = {
    where: PembelianWhereUniqueInput
    create: XOR<PembelianCreateWithoutDet_pembelianInput, PembelianUncheckedCreateWithoutDet_pembelianInput>
  }

  export type ObatCreateWithoutDet_pembelianInput = {
    id: string
    nama_obat?: string | null
    gambar?: string | null
    jenis_obat?: string | null
    tipe_obat?: string | null
    tanggal_expired?: string | null
    jumlah?: number | null
    harga_beli: number
    harga_jual: number
    stok_obat?: number | null
    kategori_obat?: string | null
    sub_kategori?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    staff: Staff_gudangCreateNestedOneWithoutObatInput
    supplier: SupplierCreateNestedOneWithoutObatInput
  }

  export type ObatUncheckedCreateWithoutDet_pembelianInput = {
    id: string
    nama_obat?: string | null
    gambar?: string | null
    jenis_obat?: string | null
    tipe_obat?: string | null
    tanggal_expired?: string | null
    jumlah?: number | null
    harga_beli: number
    harga_jual: number
    stok_obat?: number | null
    kategori_obat?: string | null
    sub_kategori?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    id_staff: string
    id_supplier: string
  }

  export type ObatCreateOrConnectWithoutDet_pembelianInput = {
    where: ObatWhereUniqueInput
    create: XOR<ObatCreateWithoutDet_pembelianInput, ObatUncheckedCreateWithoutDet_pembelianInput>
  }

  export type PembelianUpsertWithoutDet_pembelianInput = {
    update: XOR<PembelianUpdateWithoutDet_pembelianInput, PembelianUncheckedUpdateWithoutDet_pembelianInput>
    create: XOR<PembelianCreateWithoutDet_pembelianInput, PembelianUncheckedCreateWithoutDet_pembelianInput>
    where?: PembelianWhereInput
  }

  export type PembelianUpdateToOneWithWhereWithoutDet_pembelianInput = {
    where?: PembelianWhereInput
    data: XOR<PembelianUpdateWithoutDet_pembelianInput, PembelianUncheckedUpdateWithoutDet_pembelianInput>
  }

  export type PembelianUpdateWithoutDet_pembelianInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
    pelanggan?: PelangganUpdateOneRequiredWithoutPembelianNestedInput
    apoteker?: ApotekerUpdateOneRequiredWithoutPembelianNestedInput
  }

  export type PembelianUncheckedUpdateWithoutDet_pembelianInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
    id_pelanggan?: StringFieldUpdateOperationsInput | string
    id_apoteker?: StringFieldUpdateOperationsInput | string
  }

  export type ObatUpsertWithoutDet_pembelianInput = {
    update: XOR<ObatUpdateWithoutDet_pembelianInput, ObatUncheckedUpdateWithoutDet_pembelianInput>
    create: XOR<ObatCreateWithoutDet_pembelianInput, ObatUncheckedCreateWithoutDet_pembelianInput>
    where?: ObatWhereInput
  }

  export type ObatUpdateToOneWithWhereWithoutDet_pembelianInput = {
    where?: ObatWhereInput
    data: XOR<ObatUpdateWithoutDet_pembelianInput, ObatUncheckedUpdateWithoutDet_pembelianInput>
  }

  export type ObatUpdateWithoutDet_pembelianInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: Staff_gudangUpdateOneRequiredWithoutObatNestedInput
    supplier?: SupplierUpdateOneRequiredWithoutObatNestedInput
  }

  export type ObatUncheckedUpdateWithoutDet_pembelianInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_staff?: StringFieldUpdateOperationsInput | string
    id_supplier?: StringFieldUpdateOperationsInput | string
  }

  export type ObatCreateWithoutStaffInput = {
    id: string
    nama_obat?: string | null
    gambar?: string | null
    jenis_obat?: string | null
    tipe_obat?: string | null
    tanggal_expired?: string | null
    jumlah?: number | null
    harga_beli: number
    harga_jual: number
    stok_obat?: number | null
    kategori_obat?: string | null
    sub_kategori?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    supplier: SupplierCreateNestedOneWithoutObatInput
    det_pembelian?: Det_pembelianCreateNestedManyWithoutObatInput
  }

  export type ObatUncheckedCreateWithoutStaffInput = {
    id: string
    nama_obat?: string | null
    gambar?: string | null
    jenis_obat?: string | null
    tipe_obat?: string | null
    tanggal_expired?: string | null
    jumlah?: number | null
    harga_beli: number
    harga_jual: number
    stok_obat?: number | null
    kategori_obat?: string | null
    sub_kategori?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    id_supplier: string
    det_pembelian?: Det_pembelianUncheckedCreateNestedManyWithoutObatInput
  }

  export type ObatCreateOrConnectWithoutStaffInput = {
    where: ObatWhereUniqueInput
    create: XOR<ObatCreateWithoutStaffInput, ObatUncheckedCreateWithoutStaffInput>
  }

  export type ObatCreateManyStaffInputEnvelope = {
    data: ObatCreateManyStaffInput | ObatCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type ObatUpsertWithWhereUniqueWithoutStaffInput = {
    where: ObatWhereUniqueInput
    update: XOR<ObatUpdateWithoutStaffInput, ObatUncheckedUpdateWithoutStaffInput>
    create: XOR<ObatCreateWithoutStaffInput, ObatUncheckedCreateWithoutStaffInput>
  }

  export type ObatUpdateWithWhereUniqueWithoutStaffInput = {
    where: ObatWhereUniqueInput
    data: XOR<ObatUpdateWithoutStaffInput, ObatUncheckedUpdateWithoutStaffInput>
  }

  export type ObatUpdateManyWithWhereWithoutStaffInput = {
    where: ObatScalarWhereInput
    data: XOR<ObatUpdateManyMutationInput, ObatUncheckedUpdateManyWithoutStaffInput>
  }

  export type ObatScalarWhereInput = {
    AND?: ObatScalarWhereInput | ObatScalarWhereInput[]
    OR?: ObatScalarWhereInput[]
    NOT?: ObatScalarWhereInput | ObatScalarWhereInput[]
    id?: StringFilter<"Obat"> | string
    nama_obat?: StringNullableFilter<"Obat"> | string | null
    gambar?: StringNullableFilter<"Obat"> | string | null
    jenis_obat?: StringNullableFilter<"Obat"> | string | null
    tipe_obat?: StringNullableFilter<"Obat"> | string | null
    tanggal_expired?: StringNullableFilter<"Obat"> | string | null
    jumlah?: IntNullableFilter<"Obat"> | number | null
    harga_beli?: IntFilter<"Obat"> | number
    harga_jual?: IntFilter<"Obat"> | number
    stok_obat?: IntNullableFilter<"Obat"> | number | null
    kategori_obat?: StringNullableFilter<"Obat"> | string | null
    sub_kategori?: StringNullableFilter<"Obat"> | string | null
    created_at?: DateTimeFilter<"Obat"> | Date | string
    updated_at?: DateTimeFilter<"Obat"> | Date | string
    id_staff?: StringFilter<"Obat"> | string
    id_supplier?: StringFilter<"Obat"> | string
  }

  export type ObatCreateWithoutSupplierInput = {
    id: string
    nama_obat?: string | null
    gambar?: string | null
    jenis_obat?: string | null
    tipe_obat?: string | null
    tanggal_expired?: string | null
    jumlah?: number | null
    harga_beli: number
    harga_jual: number
    stok_obat?: number | null
    kategori_obat?: string | null
    sub_kategori?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    staff: Staff_gudangCreateNestedOneWithoutObatInput
    det_pembelian?: Det_pembelianCreateNestedManyWithoutObatInput
  }

  export type ObatUncheckedCreateWithoutSupplierInput = {
    id: string
    nama_obat?: string | null
    gambar?: string | null
    jenis_obat?: string | null
    tipe_obat?: string | null
    tanggal_expired?: string | null
    jumlah?: number | null
    harga_beli: number
    harga_jual: number
    stok_obat?: number | null
    kategori_obat?: string | null
    sub_kategori?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    id_staff: string
    det_pembelian?: Det_pembelianUncheckedCreateNestedManyWithoutObatInput
  }

  export type ObatCreateOrConnectWithoutSupplierInput = {
    where: ObatWhereUniqueInput
    create: XOR<ObatCreateWithoutSupplierInput, ObatUncheckedCreateWithoutSupplierInput>
  }

  export type ObatCreateManySupplierInputEnvelope = {
    data: ObatCreateManySupplierInput | ObatCreateManySupplierInput[]
    skipDuplicates?: boolean
  }

  export type ObatUpsertWithWhereUniqueWithoutSupplierInput = {
    where: ObatWhereUniqueInput
    update: XOR<ObatUpdateWithoutSupplierInput, ObatUncheckedUpdateWithoutSupplierInput>
    create: XOR<ObatCreateWithoutSupplierInput, ObatUncheckedCreateWithoutSupplierInput>
  }

  export type ObatUpdateWithWhereUniqueWithoutSupplierInput = {
    where: ObatWhereUniqueInput
    data: XOR<ObatUpdateWithoutSupplierInput, ObatUncheckedUpdateWithoutSupplierInput>
  }

  export type ObatUpdateManyWithWhereWithoutSupplierInput = {
    where: ObatScalarWhereInput
    data: XOR<ObatUpdateManyMutationInput, ObatUncheckedUpdateManyWithoutSupplierInput>
  }

  export type LaporanCreateWithoutApotekerInput = {
    id: string
    isi_laporan: string
    tanggal_laporan: string
    pemilik: PemilikCreateNestedOneWithoutLaporanInput
  }

  export type LaporanUncheckedCreateWithoutApotekerInput = {
    id: string
    isi_laporan: string
    tanggal_laporan: string
    id_pemilik: number
  }

  export type LaporanCreateOrConnectWithoutApotekerInput = {
    where: LaporanWhereUniqueInput
    create: XOR<LaporanCreateWithoutApotekerInput, LaporanUncheckedCreateWithoutApotekerInput>
  }

  export type LaporanCreateManyApotekerInputEnvelope = {
    data: LaporanCreateManyApotekerInput | LaporanCreateManyApotekerInput[]
    skipDuplicates?: boolean
  }

  export type PembelianCreateWithoutApotekerInput = {
    id: string
    jumlah_jual?: number | null
    total_harga: number
    tanggal_beli?: Date | string | null
    jumlah_beli?: string | null
    pelanggan: PelangganCreateNestedOneWithoutPembelianInput
    det_pembelian?: Det_pembelianCreateNestedManyWithoutPembelianInput
  }

  export type PembelianUncheckedCreateWithoutApotekerInput = {
    id: string
    jumlah_jual?: number | null
    total_harga: number
    tanggal_beli?: Date | string | null
    jumlah_beli?: string | null
    id_pelanggan: string
    det_pembelian?: Det_pembelianUncheckedCreateNestedManyWithoutPembelianInput
  }

  export type PembelianCreateOrConnectWithoutApotekerInput = {
    where: PembelianWhereUniqueInput
    create: XOR<PembelianCreateWithoutApotekerInput, PembelianUncheckedCreateWithoutApotekerInput>
  }

  export type PembelianCreateManyApotekerInputEnvelope = {
    data: PembelianCreateManyApotekerInput | PembelianCreateManyApotekerInput[]
    skipDuplicates?: boolean
  }

  export type LaporanUpsertWithWhereUniqueWithoutApotekerInput = {
    where: LaporanWhereUniqueInput
    update: XOR<LaporanUpdateWithoutApotekerInput, LaporanUncheckedUpdateWithoutApotekerInput>
    create: XOR<LaporanCreateWithoutApotekerInput, LaporanUncheckedCreateWithoutApotekerInput>
  }

  export type LaporanUpdateWithWhereUniqueWithoutApotekerInput = {
    where: LaporanWhereUniqueInput
    data: XOR<LaporanUpdateWithoutApotekerInput, LaporanUncheckedUpdateWithoutApotekerInput>
  }

  export type LaporanUpdateManyWithWhereWithoutApotekerInput = {
    where: LaporanScalarWhereInput
    data: XOR<LaporanUpdateManyMutationInput, LaporanUncheckedUpdateManyWithoutApotekerInput>
  }

  export type LaporanScalarWhereInput = {
    AND?: LaporanScalarWhereInput | LaporanScalarWhereInput[]
    OR?: LaporanScalarWhereInput[]
    NOT?: LaporanScalarWhereInput | LaporanScalarWhereInput[]
    id?: StringFilter<"Laporan"> | string
    isi_laporan?: StringFilter<"Laporan"> | string
    tanggal_laporan?: StringFilter<"Laporan"> | string
    id_apoteker?: StringFilter<"Laporan"> | string
    id_pemilik?: IntFilter<"Laporan"> | number
  }

  export type PembelianUpsertWithWhereUniqueWithoutApotekerInput = {
    where: PembelianWhereUniqueInput
    update: XOR<PembelianUpdateWithoutApotekerInput, PembelianUncheckedUpdateWithoutApotekerInput>
    create: XOR<PembelianCreateWithoutApotekerInput, PembelianUncheckedCreateWithoutApotekerInput>
  }

  export type PembelianUpdateWithWhereUniqueWithoutApotekerInput = {
    where: PembelianWhereUniqueInput
    data: XOR<PembelianUpdateWithoutApotekerInput, PembelianUncheckedUpdateWithoutApotekerInput>
  }

  export type PembelianUpdateManyWithWhereWithoutApotekerInput = {
    where: PembelianScalarWhereInput
    data: XOR<PembelianUpdateManyMutationInput, PembelianUncheckedUpdateManyWithoutApotekerInput>
  }

  export type PembelianScalarWhereInput = {
    AND?: PembelianScalarWhereInput | PembelianScalarWhereInput[]
    OR?: PembelianScalarWhereInput[]
    NOT?: PembelianScalarWhereInput | PembelianScalarWhereInput[]
    id?: StringFilter<"Pembelian"> | string
    jumlah_jual?: IntNullableFilter<"Pembelian"> | number | null
    total_harga?: IntFilter<"Pembelian"> | number
    tanggal_beli?: DateTimeNullableFilter<"Pembelian"> | Date | string | null
    jumlah_beli?: StringNullableFilter<"Pembelian"> | string | null
    id_pelanggan?: StringFilter<"Pembelian"> | string
    id_apoteker?: StringFilter<"Pembelian"> | string
  }

  export type PembelianCreateWithoutPelangganInput = {
    id: string
    jumlah_jual?: number | null
    total_harga: number
    tanggal_beli?: Date | string | null
    jumlah_beli?: string | null
    apoteker: ApotekerCreateNestedOneWithoutPembelianInput
    det_pembelian?: Det_pembelianCreateNestedManyWithoutPembelianInput
  }

  export type PembelianUncheckedCreateWithoutPelangganInput = {
    id: string
    jumlah_jual?: number | null
    total_harga: number
    tanggal_beli?: Date | string | null
    jumlah_beli?: string | null
    id_apoteker: string
    det_pembelian?: Det_pembelianUncheckedCreateNestedManyWithoutPembelianInput
  }

  export type PembelianCreateOrConnectWithoutPelangganInput = {
    where: PembelianWhereUniqueInput
    create: XOR<PembelianCreateWithoutPelangganInput, PembelianUncheckedCreateWithoutPelangganInput>
  }

  export type PembelianCreateManyPelangganInputEnvelope = {
    data: PembelianCreateManyPelangganInput | PembelianCreateManyPelangganInput[]
    skipDuplicates?: boolean
  }

  export type PembelianUpsertWithWhereUniqueWithoutPelangganInput = {
    where: PembelianWhereUniqueInput
    update: XOR<PembelianUpdateWithoutPelangganInput, PembelianUncheckedUpdateWithoutPelangganInput>
    create: XOR<PembelianCreateWithoutPelangganInput, PembelianUncheckedCreateWithoutPelangganInput>
  }

  export type PembelianUpdateWithWhereUniqueWithoutPelangganInput = {
    where: PembelianWhereUniqueInput
    data: XOR<PembelianUpdateWithoutPelangganInput, PembelianUncheckedUpdateWithoutPelangganInput>
  }

  export type PembelianUpdateManyWithWhereWithoutPelangganInput = {
    where: PembelianScalarWhereInput
    data: XOR<PembelianUpdateManyMutationInput, PembelianUncheckedUpdateManyWithoutPelangganInput>
  }

  export type ApotekerCreateWithoutLaporanInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    pembelian?: PembelianCreateNestedManyWithoutApotekerInput
  }

  export type ApotekerUncheckedCreateWithoutLaporanInput = {
    id: string
    nama?: string | null
    alamat?: string | null
    no_telp?: string | null
    pembelian?: PembelianUncheckedCreateNestedManyWithoutApotekerInput
  }

  export type ApotekerCreateOrConnectWithoutLaporanInput = {
    where: ApotekerWhereUniqueInput
    create: XOR<ApotekerCreateWithoutLaporanInput, ApotekerUncheckedCreateWithoutLaporanInput>
  }

  export type PemilikCreateWithoutLaporanInput = {
    id: number
    Nama?: string | null
    Alamat?: string | null
    no_telp?: string | null
  }

  export type PemilikUncheckedCreateWithoutLaporanInput = {
    id: number
    Nama?: string | null
    Alamat?: string | null
    no_telp?: string | null
  }

  export type PemilikCreateOrConnectWithoutLaporanInput = {
    where: PemilikWhereUniqueInput
    create: XOR<PemilikCreateWithoutLaporanInput, PemilikUncheckedCreateWithoutLaporanInput>
  }

  export type ApotekerUpsertWithoutLaporanInput = {
    update: XOR<ApotekerUpdateWithoutLaporanInput, ApotekerUncheckedUpdateWithoutLaporanInput>
    create: XOR<ApotekerCreateWithoutLaporanInput, ApotekerUncheckedCreateWithoutLaporanInput>
    where?: ApotekerWhereInput
  }

  export type ApotekerUpdateToOneWithWhereWithoutLaporanInput = {
    where?: ApotekerWhereInput
    data: XOR<ApotekerUpdateWithoutLaporanInput, ApotekerUncheckedUpdateWithoutLaporanInput>
  }

  export type ApotekerUpdateWithoutLaporanInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    pembelian?: PembelianUpdateManyWithoutApotekerNestedInput
  }

  export type ApotekerUncheckedUpdateWithoutLaporanInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama?: NullableStringFieldUpdateOperationsInput | string | null
    alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
    pembelian?: PembelianUncheckedUpdateManyWithoutApotekerNestedInput
  }

  export type PemilikUpsertWithoutLaporanInput = {
    update: XOR<PemilikUpdateWithoutLaporanInput, PemilikUncheckedUpdateWithoutLaporanInput>
    create: XOR<PemilikCreateWithoutLaporanInput, PemilikUncheckedCreateWithoutLaporanInput>
    where?: PemilikWhereInput
  }

  export type PemilikUpdateToOneWithWhereWithoutLaporanInput = {
    where?: PemilikWhereInput
    data: XOR<PemilikUpdateWithoutLaporanInput, PemilikUncheckedUpdateWithoutLaporanInput>
  }

  export type PemilikUpdateWithoutLaporanInput = {
    id?: IntFieldUpdateOperationsInput | number
    Nama?: NullableStringFieldUpdateOperationsInput | string | null
    Alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PemilikUncheckedUpdateWithoutLaporanInput = {
    id?: IntFieldUpdateOperationsInput | number
    Nama?: NullableStringFieldUpdateOperationsInput | string | null
    Alamat?: NullableStringFieldUpdateOperationsInput | string | null
    no_telp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LaporanCreateWithoutPemilikInput = {
    id: string
    isi_laporan: string
    tanggal_laporan: string
    apoteker: ApotekerCreateNestedOneWithoutLaporanInput
  }

  export type LaporanUncheckedCreateWithoutPemilikInput = {
    id: string
    isi_laporan: string
    tanggal_laporan: string
    id_apoteker: string
  }

  export type LaporanCreateOrConnectWithoutPemilikInput = {
    where: LaporanWhereUniqueInput
    create: XOR<LaporanCreateWithoutPemilikInput, LaporanUncheckedCreateWithoutPemilikInput>
  }

  export type LaporanCreateManyPemilikInputEnvelope = {
    data: LaporanCreateManyPemilikInput | LaporanCreateManyPemilikInput[]
    skipDuplicates?: boolean
  }

  export type LaporanUpsertWithWhereUniqueWithoutPemilikInput = {
    where: LaporanWhereUniqueInput
    update: XOR<LaporanUpdateWithoutPemilikInput, LaporanUncheckedUpdateWithoutPemilikInput>
    create: XOR<LaporanCreateWithoutPemilikInput, LaporanUncheckedCreateWithoutPemilikInput>
  }

  export type LaporanUpdateWithWhereUniqueWithoutPemilikInput = {
    where: LaporanWhereUniqueInput
    data: XOR<LaporanUpdateWithoutPemilikInput, LaporanUncheckedUpdateWithoutPemilikInput>
  }

  export type LaporanUpdateManyWithWhereWithoutPemilikInput = {
    where: LaporanScalarWhereInput
    data: XOR<LaporanUpdateManyMutationInput, LaporanUncheckedUpdateManyWithoutPemilikInput>
  }

  export type Det_pembelianCreateManyObatInput = {
    id: string
    id_faktur: string
  }

  export type Det_pembelianUpdateWithoutObatInput = {
    id?: StringFieldUpdateOperationsInput | string
    pembelian?: PembelianUpdateOneRequiredWithoutDet_pembelianNestedInput
  }

  export type Det_pembelianUncheckedUpdateWithoutObatInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_faktur?: StringFieldUpdateOperationsInput | string
  }

  export type Det_pembelianUncheckedUpdateManyWithoutObatInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_faktur?: StringFieldUpdateOperationsInput | string
  }

  export type Det_pembelianCreateManyPembelianInput = {
    id: string
    id_obat: string
  }

  export type Det_pembelianUpdateWithoutPembelianInput = {
    id?: StringFieldUpdateOperationsInput | string
    obat?: ObatUpdateOneRequiredWithoutDet_pembelianNestedInput
  }

  export type Det_pembelianUncheckedUpdateWithoutPembelianInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_obat?: StringFieldUpdateOperationsInput | string
  }

  export type Det_pembelianUncheckedUpdateManyWithoutPembelianInput = {
    id?: StringFieldUpdateOperationsInput | string
    id_obat?: StringFieldUpdateOperationsInput | string
  }

  export type ObatCreateManyStaffInput = {
    id: string
    nama_obat?: string | null
    gambar?: string | null
    jenis_obat?: string | null
    tipe_obat?: string | null
    tanggal_expired?: string | null
    jumlah?: number | null
    harga_beli: number
    harga_jual: number
    stok_obat?: number | null
    kategori_obat?: string | null
    sub_kategori?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    id_supplier: string
  }

  export type ObatUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    supplier?: SupplierUpdateOneRequiredWithoutObatNestedInput
    det_pembelian?: Det_pembelianUpdateManyWithoutObatNestedInput
  }

  export type ObatUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_supplier?: StringFieldUpdateOperationsInput | string
    det_pembelian?: Det_pembelianUncheckedUpdateManyWithoutObatNestedInput
  }

  export type ObatUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_supplier?: StringFieldUpdateOperationsInput | string
  }

  export type ObatCreateManySupplierInput = {
    id: string
    nama_obat?: string | null
    gambar?: string | null
    jenis_obat?: string | null
    tipe_obat?: string | null
    tanggal_expired?: string | null
    jumlah?: number | null
    harga_beli: number
    harga_jual: number
    stok_obat?: number | null
    kategori_obat?: string | null
    sub_kategori?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    id_staff: string
  }

  export type ObatUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: Staff_gudangUpdateOneRequiredWithoutObatNestedInput
    det_pembelian?: Det_pembelianUpdateManyWithoutObatNestedInput
  }

  export type ObatUncheckedUpdateWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_staff?: StringFieldUpdateOperationsInput | string
    det_pembelian?: Det_pembelianUncheckedUpdateManyWithoutObatNestedInput
  }

  export type ObatUncheckedUpdateManyWithoutSupplierInput = {
    id?: StringFieldUpdateOperationsInput | string
    nama_obat?: NullableStringFieldUpdateOperationsInput | string | null
    gambar?: NullableStringFieldUpdateOperationsInput | string | null
    jenis_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tipe_obat?: NullableStringFieldUpdateOperationsInput | string | null
    tanggal_expired?: NullableStringFieldUpdateOperationsInput | string | null
    jumlah?: NullableIntFieldUpdateOperationsInput | number | null
    harga_beli?: IntFieldUpdateOperationsInput | number
    harga_jual?: IntFieldUpdateOperationsInput | number
    stok_obat?: NullableIntFieldUpdateOperationsInput | number | null
    kategori_obat?: NullableStringFieldUpdateOperationsInput | string | null
    sub_kategori?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    id_staff?: StringFieldUpdateOperationsInput | string
  }

  export type LaporanCreateManyApotekerInput = {
    id: string
    isi_laporan: string
    tanggal_laporan: string
    id_pemilik: number
  }

  export type PembelianCreateManyApotekerInput = {
    id: string
    jumlah_jual?: number | null
    total_harga: number
    tanggal_beli?: Date | string | null
    jumlah_beli?: string | null
    id_pelanggan: string
  }

  export type LaporanUpdateWithoutApotekerInput = {
    id?: StringFieldUpdateOperationsInput | string
    isi_laporan?: StringFieldUpdateOperationsInput | string
    tanggal_laporan?: StringFieldUpdateOperationsInput | string
    pemilik?: PemilikUpdateOneRequiredWithoutLaporanNestedInput
  }

  export type LaporanUncheckedUpdateWithoutApotekerInput = {
    id?: StringFieldUpdateOperationsInput | string
    isi_laporan?: StringFieldUpdateOperationsInput | string
    tanggal_laporan?: StringFieldUpdateOperationsInput | string
    id_pemilik?: IntFieldUpdateOperationsInput | number
  }

  export type LaporanUncheckedUpdateManyWithoutApotekerInput = {
    id?: StringFieldUpdateOperationsInput | string
    isi_laporan?: StringFieldUpdateOperationsInput | string
    tanggal_laporan?: StringFieldUpdateOperationsInput | string
    id_pemilik?: IntFieldUpdateOperationsInput | number
  }

  export type PembelianUpdateWithoutApotekerInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
    pelanggan?: PelangganUpdateOneRequiredWithoutPembelianNestedInput
    det_pembelian?: Det_pembelianUpdateManyWithoutPembelianNestedInput
  }

  export type PembelianUncheckedUpdateWithoutApotekerInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
    id_pelanggan?: StringFieldUpdateOperationsInput | string
    det_pembelian?: Det_pembelianUncheckedUpdateManyWithoutPembelianNestedInput
  }

  export type PembelianUncheckedUpdateManyWithoutApotekerInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
    id_pelanggan?: StringFieldUpdateOperationsInput | string
  }

  export type PembelianCreateManyPelangganInput = {
    id: string
    jumlah_jual?: number | null
    total_harga: number
    tanggal_beli?: Date | string | null
    jumlah_beli?: string | null
    id_apoteker: string
  }

  export type PembelianUpdateWithoutPelangganInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
    apoteker?: ApotekerUpdateOneRequiredWithoutPembelianNestedInput
    det_pembelian?: Det_pembelianUpdateManyWithoutPembelianNestedInput
  }

  export type PembelianUncheckedUpdateWithoutPelangganInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
    id_apoteker?: StringFieldUpdateOperationsInput | string
    det_pembelian?: Det_pembelianUncheckedUpdateManyWithoutPembelianNestedInput
  }

  export type PembelianUncheckedUpdateManyWithoutPelangganInput = {
    id?: StringFieldUpdateOperationsInput | string
    jumlah_jual?: NullableIntFieldUpdateOperationsInput | number | null
    total_harga?: IntFieldUpdateOperationsInput | number
    tanggal_beli?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    jumlah_beli?: NullableStringFieldUpdateOperationsInput | string | null
    id_apoteker?: StringFieldUpdateOperationsInput | string
  }

  export type LaporanCreateManyPemilikInput = {
    id: string
    isi_laporan: string
    tanggal_laporan: string
    id_apoteker: string
  }

  export type LaporanUpdateWithoutPemilikInput = {
    id?: StringFieldUpdateOperationsInput | string
    isi_laporan?: StringFieldUpdateOperationsInput | string
    tanggal_laporan?: StringFieldUpdateOperationsInput | string
    apoteker?: ApotekerUpdateOneRequiredWithoutLaporanNestedInput
  }

  export type LaporanUncheckedUpdateWithoutPemilikInput = {
    id?: StringFieldUpdateOperationsInput | string
    isi_laporan?: StringFieldUpdateOperationsInput | string
    tanggal_laporan?: StringFieldUpdateOperationsInput | string
    id_apoteker?: StringFieldUpdateOperationsInput | string
  }

  export type LaporanUncheckedUpdateManyWithoutPemilikInput = {
    id?: StringFieldUpdateOperationsInput | string
    isi_laporan?: StringFieldUpdateOperationsInput | string
    tanggal_laporan?: StringFieldUpdateOperationsInput | string
    id_apoteker?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}